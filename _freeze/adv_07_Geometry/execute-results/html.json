{
  "hash": "4c207e5896a4a41f85a3230b41480b20",
  "result": {
    "markdown": "---\ntitle: \"Геометрические операции\"\nsubtitle: \"Геоинформатика I. Базы пространственных данных\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Геоинформатика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Основные операции\n\n::: columns\n::: {.column width=\"50%\"}\n1.  Расстояние от точки до множества точек\n2.  Расстояние между множествами точек\n3.  Периметр линии\n4.  Площадь полигона\n5.  Точка относительно прямой\n6.  Пересечение отрезков\n7.  Точка в полигоне\n8.  Центроид полигона\n9.  Точка на поверхности\n10. Точка на линии\n:::\n\n::: {.column width=\"50%\"}\n1.  Оверлей полигонов\n2.  Полигонизация линий\n3.  Триангуляция Делоне\n4.  Диаграмма Вороного\n5.  Скелет и срединная ось полигона\n6.  Буферная зона\n7.  Ограничивающий прямоугольник\n8.  Минимальный по площади ограничивающий прямоугольник\n9.  Выпуклая оболочка\n10. Вогнутая оболочка\n:::\n:::\n\n## Вектор и прямая\n\n::: columns\n::: {.column width=\"70%\"}\nПусть заданы две точки $p_1 = (x_1, y_1)$ и $p_2 = (x_2, y_2)$.\n\n**Вектор** между $p_1$ и $p_2$ определяется как\n\n$$\n\\overrightarrow{p_1p_2} = (x_2 - x_1,~y_2 - y_1)\n$$\n\n**Прямая** через $p_1$ и $p_2$ задается уравнением\n\n$$\n\\frac{y-y_1}{y_2-y_1} = \\frac{x-x_1}{x_2-x_1},\n$$\n\nи в каноническом виде\n\n$$\nax + by + c = 0\n$$\n\nгде $a = y_1-y_2$, $b = x_2 -x_1$, $c = x_1y_2 - x_2y_1$\n:::\n\n::: {.column width=\"30%\"}\n![](images/p1_p2.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до прямой\n\n::: columns\n::: {.column width=\"50%\"}\n**Евклидово расстояние** от точки $p_1$ до точки $p_2$ вычисляется как:\n\n$$\nd(p_1,p_2) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\n$$\n\n**Расстояние** от точки $p = (x_p, y_p)$ до прямой $l$ вычисляется как:\n\n$$\nd(p, l) = \\frac{|ax_p + by_p + c|}{\\sqrt{a^2 + b^2}}\n$$\n\nгде $a$, $b$ и $c$ --- коэффициенты уравнения прямой $l$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/d_p_l.svg){width=\"80%\"}\n:::\n:::\n\n## Расстояние от точки до отрезка\n\nВ зависимости от конфигурации это может быть как расстояние до прямой, так и расстояние до одной из крайних точек отрезка.\n\n::: columns\n::: {.column width=\"60%\"}\nПусть дана точка $p$ и отрезок $\\overline{qr}$, лежащий на прямой $l$. Введем три вектора:\n\n$$\n\\mathbf u = \\overrightarrow{qp},~\\mathbf v = \\overrightarrow{pr},~\\mathbf w = \\overrightarrow{qr}\n$$\n\nТогда расстояние определится как:\n\n$$\n\\mathrm d(p, \\overline{qr}) = \\begin{cases}\n\\mathrm d(p, q),~если~(\\mathbf u, \\mathbf w) < 0; \\\\\n\\mathrm d(p, r),~если~(\\mathbf v, \\mathbf w) < 0; \\\\\n\\mathrm d(p, l)~\\textrm{в противном случае}\n\\end{cases}\n$$\n\nгде $(\\mathbf a, \\mathbf b) = x_a x_b + y_a y_b$ --- скалярное произведение векторов\n:::\n\n::: {.column width=\"40%\"}\n![](images/point_segment_dist.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до линии\n\n**Расстояние от точки до линии** $L$ , состоящей из $k$ вершин --- это минимальное из расстояний от точки до каждого из отрезков линии:\n\n$$\nd(p, L) = \\min \\big[\\textrm d(p, \\overline{p_j p_{j+1}})\\big], ~j=0...k-1\n$$\n\n::: columns\n::: {.column width=\"30%\"}\n::: callout-note\n## Аппроксимация\n\nЕсли длины сегментов линии существенно меньше, чем расстояние до точки, то в качестве приближения можно взять расстояние до ближайшей точки линии.\n:::\n:::\n\n::: {.column width=\"70%\"}\n![](images/d_p_polyline.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до полигона\n\n**Расстояние от точки до полигона** $A$, состоящего из $n$ колец, равняется $0$, если точка внутри полигона, иначе равна минимальному расстоянию до границы полигона.\n\n$$\nd(p, A) = \\min\\big[\\textrm d(p, \\overline{p_{i,j} p_{i,j+1}})\\big],~i = 0...n-1,~j = 0...k_i\n$$\n\n::: columns\n::: {.column width=\"40%\"}\n::: callout-note\n## Точка в полигоне\n\nДля определения принадлежности точки полигону необходимо использовать соответствующий тест\n:::\n:::\n\n::: {.column width=\"60%\"}\n![](images/d_p_polygon.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние Хаусдорфа\n\nЕсли даны два подмножества $\\mathcal{A} = \\lbrace a \\rbrace$ и $\\mathcal{B} = \\lbrace b \\rbrace$ метрического пространства $M$ с заданным расстоянием $d$, то **расстояние** **Хаусдорфа** $d_H(\\mathcal{A}, \\mathcal{B})$ вычисляется как:\n\n$$\nd_{\\mathrm H}(\\mathcal{A},\\mathcal{B}) = \\max\\left\\{\\,\\sup_{a \\in \\mathcal{A}} \\inf_{b \\in \\mathcal{B}} d(a,b),\\, \\sup_{b \\in \\mathcal{B}} \\inf_{a \\in \\mathcal{A}} d(a,b)\\,\\right\\}\n$$\n\nНа практике, когда $\\mathcal{A}$ и $\\mathcal{B}$ являются конечными точечными множествами, вычисляется дискретная версия $d_H$.\n\n-   для каждой точки $a$ в $\\mathcal{A}$ находится ближайшая точка $b_a$ в $\\mathcal{B}$ и $\\vec{d}_H(\\mathcal{A},\\mathcal{B}) = \\underset{a}{\\max}~d(a, b_a)$ как приближение $\\sup_{a \\in \\mathcal{A}} \\inf_{b \\in \\mathcal{B}} d(a,b)$.\n\n-   для каждой точки $b$ в $\\mathcal{B}$ находится ближайшая точка $a_b$ в $\\mathcal{A}$ и $\\vec{d}_H(\\mathcal{B},\\mathcal{A}) = \\underset{b}{\\max}~d(b, a_b)$ как приближение $\\sup_{b \\in \\mathcal{B}} \\inf_{a \\in \\mathcal{A}} d(a,b)$.\n\n## Дискретное расстояние Хаусдорфа\n\n**Дискретное расстояние Хаусдорфа** определяется как:\n\n$$\n\\widehat {d_H}(\\mathcal{A},\\mathcal{B}) = \\max \\left\\{\\vec{d}_H(\\mathcal{A},\\mathcal{B}),\\, \\vec{d}_H(\\mathcal{B},\\mathcal{A}) \\right\\}\n$$\n\nВеличина $\\vec{d}_H$ называется *направленным расстоянием Хаусдорфа*.\n\n::: callout-warning\n## Чувствительность к выбросам\n\nИ $d_H$, и $\\widehat{d_H}$ являются мимимаксными мерами, они чувствительны к выбросам из множества.\n:::\n\n**Модифицированное расстояние Хаусдорфа** заменяет максимум кратчайших расстояний их средним значением, что устраняет чувствительность к выбросам:\n\n$$\nd_M = \\max \\left\\{\\frac{1}{|\\mathcal{A}|}\\underset{a}{\\sum} d(a, b_a),\\, \\frac{1}{|\\mathcal{B}|}\\underset{b}{\\sum} d(b, a_b) \\right\\}\n$$\n\n## Длина / периметр\n\n::: columns\n::: {.column width=\"50%\"}\nРассчитываются как сумма длин отрезков, составляющих контур объекта:\n\n$$\n\\sum_{i=0}^{n-2}\\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}\n$$\n\n::: callout-note\n## Полигон\n\nУ полигона последняя точка должна иметь такие же координаты, как и первая.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/perimeter.svg){width=\"100%\"}\n:::\n:::\n\n## Площадь\n\n::: columns\n::: {.column width=\"50%\"}\nРассчитывается как сумма площадей трапеций, ограниченных сверху отрезками, составляющими контур объекта:\n\n$$\n\\frac{1}{2}\\sum_{i=0}^{n-2} \\underbrace{(y_{i+1}+y_{i})}_{\\texttt{основания}}\\underbrace{(x_{i+1}-x_{i})}_{\\texttt{высота}}\n$$\n\n::: callout-note\n## Отрицательная площадь\n\nТрапеции, у которых $i+1$-я точка имеет меньший X, чем $i$-я, имеют отрицательную площадь.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/area.svg){width=\"100%\"}\n:::\n:::\n\n## Точка относительно прямой\n\n::: columns\n::: {.column width=\"60%\"}\nПусть прямая $l$ определяется отрезком $\\overline{qr}$. Расположение точки $p$ относительно этой прямой зависит от знака площади треугольника $\\triangle qpr$:\n:::\n\n::: {.column width=\"40%\"}\n![](images/triangle_area.svg){width=\"100%\"}\n:::\n:::\n\n$$\n\\texttt{area}(\\triangle qpr) = \\frac{1}{2}\\big[x_q y_p - x_p y_q + x_p y_r - x_r y_p + x_r y_q - x_q y_r \\big]\n$$\n\n$$\n\\texttt{side}(q,p,r) = \\begin{cases} \n1,\\textrm{ если } \\texttt{area}(\\triangle qpr) > 0~(p \\textrm{ слева от } l),\\\\\n0,\\textrm{ если } \\texttt{area}(\\triangle qpr) = 0~(p \\textrm{ на } l),\\\\\n-1,\\textrm{ если } \\texttt{area}(\\triangle qpr) < 0~(p \\textrm{ справа от } l),\\\\\n\\end{cases}\n$$\n\n## Пересечение отрезков\n\n::: columns\n::: {.column width=\"60%\"}\n**Отрезки пересекаются**, если их точки попарно располагаются по разные стороны от соответствующих прямых.\n\nВ этом случае *одновременно* выполняются два условия:\n\n$$\n\\texttt{side}(p_1, p_2, p_3) \\neq \\texttt{side}(p_1, p_2, p_4)\\\\ \n\\texttt{side}(p_3, p_4, p_1) \\neq \\texttt{side}(p_3, p_4, p_2)\n$$\n:::\n\n::: {.column width=\"40%\"}\n![](images/segment_intersection.svg){width=\"100%\"}\n:::\n:::\n\nЕсли отрезки коллинеарны, то надо проверять расстояния:\n\n$$\n\\textrm d(p_3, \\overline{p_1 p_2}) < \\epsilon,~\\textrm d(p_4, \\overline{p_1 p_2}) < \\epsilon,~\\textrm d(p_1, \\overline{p_3 p_4}) < \\epsilon,~\\textrm d(p_2, \\overline{p_3 p_4}) < \\epsilon\n$$\n\n## Точка пересечения\n\nПредставим отрезки в параметрическом виде:\n\n$$\n\\overline{p_1 p_2} = \\{\\lambda p_1 + (1 - \\lambda) p_2 | \\lambda \\in [0,1]\\}\\\\\n\\overline{p_3 p_4} = \\{\\mu p_3 + (1 - \\mu) p_4 | \\lambda \\in [0,1]\\}\n$$Если отрезки пересекаются, то справедливо равенство:\n\n$$\n\\lambda p_1 + (1 - \\lambda) p_2 = \\mu p_3 + (1 - \\mu) p_4\\\\\n\\lambda(p_1 - p_2) - \\mu(p_3 - p_4) = p_4 - p_2\n$$\n\nПереходя от точек к координатам получаем систему уравнений:\n\n$$\n\\begin{cases}\n\\lambda(x_1 - x_2) - \\mu(x_3 - x_4) = x_4 - x_2\\\\\n\\lambda(y_1 - y_2) - \\mu(y_3 - y_4) = y_4 - y_2\n\\end{cases}\n$$\n\nРешив систему относительно $\\lambda$ и $\\mu$, получаем точку пересечения.\n\n## Принадлежность точки полигону\n\nЛуч, выпущенный из точки в направлении оси $X$, *сечёт* (`crosses`) границу полигона **нечетное** количество раз.\n\n::: columns\n::: {.column width=\"60%\"}\n![](images/point_polygon.svg){width=\"90%\"}\n:::\n\n::: {.column width=\"40%\"}\n### Обратите внимание\n\nЕсли луч пересекает одну из *вершин* полигона, и оба примыкающих к ней отрезка находятся по одну сторону от луча, то это не сечение, а *касание* границы, которое не должно влиять на результат.\n:::\n:::\n\nЕсли полигон состоит из вершин $p_i = (x_i, y_i)$, то в качестве луча можно взять отрезок $\\overline{pq}$, где $q = (max(x_i), y_p)$.\n\n## Библиография\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}