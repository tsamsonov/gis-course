{
  "hash": "38fb937dbcd2463355bf07335d402bdf",
  "result": {
    "markdown": "---\ntitle: \"Геометрические операции\"\nsubtitle: \"Геоинформатика I. Базы пространственных данных\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Геоинформатика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Основные операции\n\n::: columns\n::: {.column width=\"50%\"}\n1.  Расстояние от точки до множества точек\n2.  Расстояние между множествами точек\n3.  Периметр линии\n4.  Площадь полигона\n5.  Точка относительно прямой\n6.  Точка относительно отрезка\n7.  Пересечение отрезков\n8.  Точка в полигоне\n9.  Центроид полигона\n10. Точка на поверхности\n:::\n\n::: {.column width=\"50%\"}\n1.  Оверлей полигонов\n2.  Слияние линий и полигонов\n3.  Полигонизация линий\n4.  Триангуляция Делоне\n5.  Диаграмма Вороного\n6.  Скелет и срединная ось полигона\n7.  Буферная зона\n8.  Ограничивающий прямоугольник\n9.  Минимальный по площади ограничивающий прямоугольник\n10. Выпуклая и вогнутая оболочка\n:::\n:::\n\n## Вектор и прямая\n\n::: columns\n::: {.column width=\"70%\"}\nПусть заданы две точки $p_1 = (x_1, y_1)$ и $p_2 = (x_2, y_2)$.\n\n**Вектор** между $p_1$ и $p_2$ определяется как\n\n$$\n\\overrightarrow{p_1p_2} = (x_2 - x_1,~y_2 - y_1)\n$$\n\n**Прямая** через $p_1$ и $p_2$ задается уравнением\n\n$$\n\\frac{y-y_1}{y_2-y_1} = \\frac{x-x_1}{x_2-x_1},\n$$\n\nи в каноническом виде\n\n$$\nax + by + c = 0\n$$\n\nгде $a = y_1-y_2$, $b = x_2 -x_1$, $c = x_1y_2 - x_2y_1$\n:::\n\n::: {.column width=\"30%\"}\n![](images/p1_p2.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до прямой\n\n::: columns\n::: {.column width=\"50%\"}\n**Евклидово расстояние** от точки $p_1$ до точки $p_2$ вычисляется как:\n\n$$\nd(p_1,p_2) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\n$$\n\n**Расстояние** от точки $p = (x_p, y_p)$ до прямой $l$ вычисляется как:\n\n$$\nd(p, l) = \\frac{|ax_p + by_p + c|}{\\sqrt{a^2 + b^2}}\n$$\n\nгде $a$, $b$ и $c$ --- коэффициенты уравнения прямой $l$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/d_p_l.svg){width=\"80%\"}\n:::\n:::\n\n## Расстояние от точки до отрезка\n\nВ зависимости от конфигурации это может быть как расстояние до прямой, так и расстояние до одной из крайних точек отрезка.\n\n::: columns\n::: {.column width=\"60%\"}\nПусть дана точка $p$ и отрезок $\\overline{qr}$, лежащий на прямой $l$. Введем три вектора:\n\n$$\n\\mathbf u = \\overrightarrow{qp},~\\mathbf v = \\overrightarrow{pr},~\\mathbf w = \\overrightarrow{qr}\n$$\n\nТогда расстояние определится как:\n\n$$\n\\mathrm d(p, \\overline{qr}) = \\begin{cases}\n\\mathrm d(p, q),~если~(\\mathbf u, \\mathbf w) < 0; \\\\\n\\mathrm d(p, r),~если~(\\mathbf v, \\mathbf w) < 0; \\\\\n\\mathrm d(p, l)~\\textrm{в противном случае}\n\\end{cases}\n$$\n\nгде $(\\mathbf a, \\mathbf b) = x_a x_b + y_a y_b$ --- скалярное произведение векторов\n:::\n\n::: {.column width=\"40%\"}\n![](images/point_segment_dist.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до линии\n\n**Расстояние от точки до линии** $L$ , состоящей из $k$ вершин --- это минимальное из расстояний от точки до каждого из отрезков линии:\n\n$$\nd(p, L) = \\min \\big[\\textrm d(p, \\overline{p_j p_{j+1}})\\big], ~j=0...k-2\n$$\n\n::: columns\n::: {.column width=\"30%\"}\n::: callout-note\n## Аппроксимация\n\nЕсли длины сегментов линии существенно меньше, чем расстояние до точки, то в качестве приближения можно взять расстояние до ближайшей точки линии.\n:::\n:::\n\n::: {.column width=\"70%\"}\n![](images/d_p_polyline.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояние от точки до полигона\n\n**Расстояние от точки до полигона** $A$, состоящего из $n$ колец, равняется $0$, если точка внутри полигона, иначе равна минимальному расстоянию до границы полигона.\n\n$$\nd(p, A) = \\min\\big[\\textrm d(p, \\overline{p_{i,j} p_{i,j+1}})\\big],~i = 0...n-1,~j = 0...k_i-2\n$$\n\n::: columns\n::: {.column width=\"40%\"}\n::: callout-note\n## Точка в полигоне\n\nДля определения принадлежности точки полигону необходимо использовать соответствующий тест\n:::\n:::\n\n::: {.column width=\"60%\"}\n![](images/d_p_polygon.svg){width=\"100%\"}\n:::\n:::\n\n## Расстояния между множествами точек\n\nОднозначность определения расстояния теряется, когда его необходимо определить между двумя множествами точек.\n\n![](images/d_pointset.svg){width=\"100%\"}\n\n## Расстояния между множествами точек\n\nВ частности, такими множествами могут быть линии. Должно ли это быть расстояние между ближайшими, дальними или конечными точками линий?\n\n![](images/d_lineset.svg){width=\"100%\"}\n\n## Расстояние Хаусдорфа (simplified)\n\nДля каждой точки из $\\mathcal A$ вычислим расстояние до ближайшей точки из $\\mathcal B$ и выберем из них максимальное.\n\n![](images/hausdorff_1.svg){width=\"100%\"}\n\n## Расстояние Хаусдорфа (simplified)\n\nДля каждой точки из $\\mathcal B$ вычислим расстояние до ближайшей точки из $\\mathcal A$ и выберем из них максимальное.\n\n![](images/hausforff_2.svg){width=\"100%\"}\n\n## Расстояние Хаусдорфа (simplified)\n\nCравним полученные расстояния и выберем из них максимальное.\n\n![](images/hausdorff_3.svg){width=\"100%\"}\n\n## Расстояние Хаусдорфа (simplified)\n\nПолученное расстояние будем называть **расстоянием Хаусдорфа** (или Хаусдорфовым расстоянием).\n\n![](images/hausdorff_4.svg){width=\"100%\"}\n\n## Расстояние Хаусдорфа\n\nЕсли даны два подмножества $\\mathcal{A} = \\lbrace a \\rbrace$ и $\\mathcal{B} = \\lbrace b \\rbrace$ метрического пространства $M$ с заданным расстоянием $\\mathrm d$, то **расстояние** **Хаусдорфа** $\\textrm d_H(\\mathcal{A}, \\mathcal{B})$ вычисляется как:\n\n$$\n\\mathrm d_{\\mathrm H}(\\mathcal{A},\\mathcal{B}) = \\max\\left\\{\\,\\sup_{a \\in \\mathcal{A}} \\inf_{b \\in \\mathcal{B}} \\mathrm d(a,b),\\, \\sup_{b \\in \\mathcal{B}} \\inf_{a \\in \\mathcal{A}} \\mathrm d(a,b)\\,\\right\\}\n$$\n\nНа практике, когда $\\mathcal{A}$ и $\\mathcal{B}$ являются конечными точечными множествами, вычисляется дискретная версия $\\widehat{\\mathrm d_H}$ на основе двух расстояний:\n\n-   $\\vec{\\mathrm d}_H(\\mathcal{A},\\mathcal{B}) = \\underset{a}{\\max}~\\mathrm d(a, \\mathcal{B})$, где $d(a, \\mathcal{B}) = \\min_{b \\in \\mathcal{B}}\\lVert a - b \\rVert$ как приближение $\\sup_{a \\in \\mathcal{A}} \\inf_{b \\in \\mathcal{B}} d(a,b)$.\n\n-   $\\vec{\\mathrm d}_H(\\mathcal{B},\\mathcal{A}) = \\underset{b}{\\max}~\\mathrm d(b, \\mathcal A)$, где $d(b, \\mathcal{A}) = \\min_{a \\in \\mathcal{A}}\\lVert b - a \\rVert$ как приближение $\\sup_{b \\in \\mathcal{B}} \\inf_{a \\in \\mathcal{A}} d(a,b)$.\n\n## Дискретное расстояние Хаусдорфа\n\n**Дискретное расстояние Хаусдорфа** определяется как:\n\n$$\n\\widehat {\\mathrm d_H}(\\mathcal{A},\\mathcal{B}) = \\max \\left\\{\\vec{\\mathrm d}_H(\\mathcal{A},\\mathcal{B}),\\, \\vec{\\mathrm d}_H(\\mathcal{B},\\mathcal{A}) \\right\\}\n$$\n\nВеличина $\\vec{\\mathrm d}_H$ называется *направленным расстоянием Хаусдорфа*.\n\n::: callout-warning\n## Чувствительность к выбросам\n\nИ $\\mathrm d_H$, и $\\widehat{\\mathrm d_H}$ являются мимимаксными мерами, они чувствительны к выбросам из множества.\n:::\n\n**Модифицированное расстояние Хаусдорфа** заменяет максимум кратчайших расстояний их средним значением, что устраняет чувствительность к выбросам:\n\n$$\n\\mathrm d_M = \\max \\left\\{\\frac{1}{|\\mathcal{A}|}\\underset{a}{\\sum} \\mathrm d(a, \\mathcal B),\\, \\frac{1}{|\\mathcal{B}|}\\underset{b}{\\sum} \\mathrm d(b, \\mathcal A) \\right\\}\n$$\n\n## Модифицированное расстояние Хаусдорфа\n\nМодифицированное расстояние Хаусдорфа может использоваться в качестве приближенной метрики расстояния между линиями. Однако оно не учитывает *непрерывность и направление линии*.\n\n![](images/hausdorff_line.svg){width=\"100%\"}\n\n## Модифицированное расстояние Хаусдорфа\n\nДанная метрика работает только в простых случаях, когда линии идут параллельными путями. На рисунке ниже расстояние Хаусдорфа и его модификации не эффективны.\n\n![](images/hausdorff_ineffective.svg){width=\"100%\"}\n\n## Расстояние Фреше\n\nМинимальная длина поводка, который нужен хозяину, чтобы выгулять собаку при том, что оба они идут разными дорожками от начала до конца.\n\n![](images/frechet_distance.svg){width=\"100%\"}\n\n## Расстояние Фреше\n\n**Расстояние Фреше** является мерой близости линий с учетом их непрерывности и направления:\n\n$$\n\\mathrm d_F(\\mathcal{A},\\mathcal{B}) = \\inf_{\\alpha, \\beta}\\,\\,\\max_{t \\in [0,1]} \\,\\, \\Bigg \\{\\mathrm d \\Big (\\mathcal{A}\\big(\\alpha(t)\\big), \\, \\mathcal{B}\\big(\\beta(t)\\big) \\Big ) \\Bigg \\},\n$$\n\nгде $\\mathcal{A}(u),~\\mathcal{B}(v),~u,v \\in [0, 1]$ --- *параметрические описания* линий\n\n$\\alpha(t),~\\beta(t),~t \\in [0, 1]$ --- *репараметризации*, которые оптимизируются для нахождения таких $u = \\alpha(t)$ и $v = \\beta(t)$, которые минимизируют максимальное расстояние между $\\mathcal{A}(u)$ и $\\mathcal{B}(v)$ для общего $t$.\n\n::: callout-note\n## Аналогия\n\nРасстояние Фреше --- это минимальная длина поводка, который нужен хозяину, чтобы выгулять собаку при том, что оба они идут разными дорожками от начала до конца.\n:::\n\n## Длина / периметр\n\n::: columns\n::: {.column width=\"50%\"}\nРассчитываются как сумма длин отрезков, составляющих контур объекта:\n\n$$\n\\sum_{i=0}^{n-2}\\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}\n$$\n\n::: callout-note\n## Полигон\n\nУ полигона последняя точка должна иметь такие же координаты, как и первая.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/perimeter.svg){width=\"100%\"}\n:::\n:::\n\n## Площадь\n\n::: columns\n::: {.column width=\"50%\"}\nРассчитывается как сумма площадей трапеций, ограниченных сверху отрезками, составляющими контур объекта:\n\n$$\n\\frac{1}{2}\\sum_{i=0}^{n-2} \\underbrace{(y_{i+1}+y_{i})}_{\\texttt{основания}}\\underbrace{(x_{i+1}-x_{i})}_{\\texttt{высота}}\n$$\n\n::: callout-note\n## Отрицательная площадь\n\nТрапеции, у которых $i+1$-я точка имеет меньший X, чем $i$-я, имеют отрицательную площадь.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/area.svg){width=\"100%\"}\n:::\n:::\n\n## Точка относительно прямой\n\n::: columns\n::: {.column width=\"60%\"}\nПусть прямая $l$ определяется отрезком $\\overline{qr}$. Расположение точки $p$ относительно этой прямой зависит от знака площади треугольника $\\triangle qpr$:\n:::\n\n::: {.column width=\"40%\"}\n![](images/triangle_area.svg){width=\"100%\"}\n:::\n:::\n\n$$\n\\texttt{area}(\\triangle qpr) = \\frac{1}{2}\\big[x_q y_p - x_p y_q + x_p y_r - x_r y_p + x_r y_q - x_q y_r \\big]\n$$\n\n$$\n\\texttt{side}(q,p,r) = \\begin{cases} \n1,\\textrm{ если } \\texttt{area}(\\triangle qpr) > 0~(p \\textrm{ слева от } l),\\\\\n0,\\textrm{ если } \\texttt{area}(\\triangle qpr) = 0~(p \\textrm{ на } l),\\\\\n-1,\\textrm{ если } \\texttt{area}(\\triangle qpr) < 0~(p \\textrm{ справа от } l),\\\\\n\\end{cases}\n$$\n\n## Точка на отрезке\n\n::: columns\n::: {.column width=\"60%\"}\nТочка $p$ располагается на отрезке $\\overline{qr}$, если одновременно выполняются $3$ условия:\n\n$$\n\\texttt{point_on_segment}(p,\\overline{qr}) = \\big(\\texttt{side}(q,p,r) = 0\\big) \\\\\n\\land \\big(\\min(x_q, x_r) \\leq x_p \\leq \\max(x_q, x_r)\\big) \\\\\n\\land \\big(\\min(y_q, y_r) \\leq y_p \\leq \\max(y_q, y_r)\\big)\n$$\n\n::: callout-note\n## Точность вычислений\n\nДля того чтобы избежать ошибок, связанных с ограниченной точностью вычислений, часто выполняют не проверку равенства нулю, а сравнение с очень малым числом: $|\\texttt{side}(q,p,r)| < \\epsilon$, где $\\epsilon$ задается как константа в программе. Например, `EPS = 1e-9`.\n:::\n:::\n\n::: {.column width=\"40%\"}\n![](images/point_on_segment.svg){width=\"100%\"}\n:::\n:::\n\n## Пересечение отрезков\n\n::: columns\n::: {.column width=\"60%\"}\n**Отрезки пересекаются**, если их точки попарно располагаются по разные стороны от соответствующих прямых.\n\nВ этом случае *одновременно* выполняются два условия:\n\n$$\n\\texttt{side}(p_1, p_2, p_3) \\neq \\texttt{side}(p_1, p_2, p_4)\\\\ \n\\texttt{side}(p_3, p_4, p_1) \\neq \\texttt{side}(p_3, p_4, p_2)\n$$\n:::\n\n::: {.column width=\"40%\"}\n![](images/segment_intersection.svg){width=\"100%\"}\n:::\n:::\n\nЕсли отрезки коллинеарны, то надо проверять условия вида:\n\n$$\n\\texttt{point_on_segment}(p_3, \\overline{p_1 p_2}),~\\texttt{point_on_segment}(p_4, \\overline{p_1 p_2})\n$$\n\n## Точка пересечения\n\nПредставим отрезки в параметрическом виде:\n\n$$\n\\overline{p_1 p_2} = \\{\\lambda p_1 + (1 - \\lambda) p_2 | \\lambda \\in [0,1]\\}\\\\\n\\overline{p_3 p_4} = \\{\\mu p_3 + (1 - \\mu) p_4 | \\mu \\in [0,1]\\}\n$$Если отрезки пересекаются, то справедливо равенство:\n\n$$\n\\lambda p_1 + (1 - \\lambda) p_2 = \\mu p_3 + (1 - \\mu) p_4\\\\\n\\lambda(p_1 - p_2) - \\mu(p_3 - p_4) = p_4 - p_2\n$$\n\nПереходя от точек к координатам получаем систему уравнений:\n\n$$\n\\begin{cases}\n\\lambda(x_1 - x_2) - \\mu(x_3 - x_4) = x_4 - x_2\\\\\n\\lambda(y_1 - y_2) - \\mu(y_3 - y_4) = y_4 - y_2\n\\end{cases}\n$$\n\nРешив систему относительно $\\lambda$ и $\\mu$, получаем точку пересечения.\n\n## Выпуклость полигона\n\nПолигон является выпуклым, если каждая последующая его точка одинаково располагается относительно прямой, проходящей через две предыдущих.\n\n$$\n\\texttt{side}(p_0, p_1, p_2) = \\texttt{side}(p_1, p_2, p_3) = ... = \\texttt{side}(p_{n-3}, p_{n-2}, p_{n-1})\n$$\n\n![](images/convex_polygon.svg){width=\"100%\"}\n\n## Точка в выпуклом полигоне\n\nЕсли полигон является выпуклым, то все его внутренние точки располагаются по одну сторону относительно границы.\n\n$$\n\\texttt{side}(p, p_1, p_2) = \\texttt{side}(p, p_2, p_3) = ... = \\texttt{side}(p, p_{n-2}, p_{n-1})\n$$\n\n![](images/point_convex_polygon.svg){width=\"100%\"}\n\n## Точка в полигоне (луч)\n\nЛуч, выпущенный из точки в направлении оси $X$, *сечёт* (`crosses`) границу полигона **нечетное** количество раз.\n\n::: columns\n::: {.column width=\"60%\"}\n![](images/point_in_polygon.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"40%\"}\n### Обратите внимание\n\nЕсли луч пересекает одну из *вершин* полигона, и оба примыкающих к ней отрезка находятся по одну сторону от луча, то это не сечение, а *касание* границы, которое не должно влиять на результат.\n:::\n:::\n\nЕсли полигон состоит из вершин $p_i = (x_i, y_i)$, то в качестве луча можно взять отрезок $\\overline{pq}$, где $q = (max(x_i), y_p)$.\n\n## Угол между векторами\n\nУгол $0 \\leq \\theta \\leq \\pi$ между векторами определяется через скалярное произведение:\n\n$$\n(\\mathbf u, \\mathbf v) = |\\mathbf u||\\mathbf v| \\cos \\theta \\Rightarrow \\theta = \\arccos \\frac{(\\mathbf u, \\mathbf v)}{|\\mathbf u||\\mathbf v|} \\\\\n\\theta = \\arccos \\frac{u_x v_x + u_y v_y}{\\sqrt{u_x^2 + u_y^2}\\sqrt{v_x^2 + v_y^2}}\n$$\n\n![](images/vector_angle.svg){width=\"100%\"}\n\n## Порядок точки\n\n**Порядок точки** относительно замкнутой кривой --- число полных оборотов, которое кривая делает вокруг заданной точки против часовой стрелки.\n\n![](images/winding_curve.svg){width=\"100%\"}\n\n## Точка в полигоне (угол)\n\nТочка находится внутри, если число оборотов не равно 0:\n\n$$\n\\newcommand\\sgn{{\\mathrm{sgn}}}\n\\sum_{i=0}^{n-2} \\varphi_i \\neq 0,~где~\\varphi_i = \\sgn \\begin{vmatrix} v^x_i & v^y_i \\\\ v^x_{i+1} & v^y_{i+1}  \\end{vmatrix} \\arccos \\frac{(\\mathbf v_i, \\mathbf v_{i+1})}{|\\mathbf v_i||\\mathbf v_{i+1}|}, \\\\\nгде~\\mathbf v_i = \\overrightarrow{pp_i} = (v^x_i, v^y_i) = (x_i - x_p,~y_i - y_p)\n$$\n\n![](images/point_winding_polygon.svg){width=\"100%\"}\n\n## Ограничивающий прямоугольник\n\n::: columns\n::: {.column width=\"60%\"}\n**Ограничивающий прямоугольник** определяет охват данных по осям координат.\n\nЗадаётся координатами углов:\n\n-   левого нижнего $(x_{min}, y_{min})$\n\n-   правого верхнего $(x_{max}, y_{max})$\n\n::: callout-tip\n## Применение\n\nОграничивающий прямоугольник является важным элементом *метаданных* --- описания пространственных данных, но также используется и в аналитических задачах.\n:::\n:::\n\n::: {.column width=\"40%\"}\n![](images/bbox.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\n::: columns\n::: {.column width=\"50%\"}\n**Выпуклая оболочка** --- наименьший по площади выпуклый многоугольник, *покрывающий* заданное множество точек.\n\n::: callout-note\n## Выпуклое множество\n\nМножество, в котором отрезок, соединяющий любые две точки также находится внутри этого множества.\n\n![](images/non_convex.svg){width=\"65%\"}\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/convex_hull.svg){width=\"60%\"}\n\n::: callout-tip\n## Применение\n\nВыпуклые оболочки используются для восстановления ареалов по точечным измерениям. Также выпуклая оболочка является границей *триангуляционного покрытия*.\n:::\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_1.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_2.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n$k = 2,~q_2 \\neq q_0$\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_3.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n$k=3,~q_3 \\neq q_0$\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_4.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n$k=4,~q_4 \\neq q_0$\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_5.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n$k=5,~q_5 \\neq q_0$\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_6.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n$k=6,~q_6 = q_0$\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_7.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nИзвестный метод построения --- **алгоритм Джарвиса** [@jarvis1973]:\n\n::: columns\n::: {.column width=\"55%\"}\n1.  Найти точку $q_0$ с минимальной координатой $X$.\n\n2.  Найти точку $q_1$ с минимальным дирекционным углом относительно $q_0$.\n\n3.  Пока $q_k \\neq q_0$ начиная с $k=1$\n\n    -   найти точку $q_{k+1}$ с минимальным углом поворота относительно прямой, проходящей через отрезок $\\overline{q_{k-1}q_k}$;\n\n    -   $k = k + 1$.\n\n4.  Восстановить полигон по точкам $q_0, q_1, … q_k$, где $k > 2$ и $q_0 = q_k$.\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_8.svg){width=\"100%\"}\n:::\n:::\n\n## Выпуклая оболочка\n\nАлгоритм Джарвиса без вычисления углов: минимальный угол поворота означает, что остальные точки располагаются *по правую сторону относительно* $\\overrightarrow{qr}$.\n\nПусть $P = \\{p_i\\}$ --- множество точек и $Q = \\{q_j\\}$ --- искомая выпуклая оболочка.\n\n::: columns\n::: {.column width=\"55%\"}\n1.  $Q = \\varnothing;~q =\\min_x p$\n\n2.  В цикле (`while True`):\n\n    -   $Q = Q \\cup q;~r = p_0$\n\n    -   В цикле по $i$ от $0$ до $n-1$:\n\n        -   если $r = q$ или $\\texttt{side}(q, p_i, r) = 1$\n\n            -   $r = p_i$\n\n    -   $q = r$\n\n    -   Если $q = q_0$, то $Q = Q \\cup q$ и прервать цикл\n:::\n\n::: {.column width=\"45%\"}\n![](images/convex_hull_8.svg){width=\"80%\"}\n:::\n:::\n\n## Аффинные преобразования\n\n**Аффинное преобразование** $f\\colon\\mathbb{R}^{n}\\to \\mathbb{R}^{n}$ есть преобразование вида:\n\n$$\nf(\\mathrm p) = \\mathbf M \\cdot \\mathrm p + \\mathrm v\n$$\n\nгде $\\mathbf M$ --- *обратимая матрица* (квадратная матрица, определитель которой отличен от нуля) и $v\\in \\mathbb{R}^{n}$.\n\n$\\mathbf M$ и $\\mathrm v$ обычно объединяются в одну матрицу $\\mathbf A$, что требует представления $p$ в *однородных* координатах: $\\widehat{\\mathrm p} = (x_p, y_p,..., 1)$. В этом случае аффинное преобразование можно записать как:\n\n$$\nf(\\mathrm p) = \\mathbf A \\cdot \\widehat{\\mathrm p} = \\left[ \\begin{array}{ccc|c} \\, & \\mathbf M & & \\mathrm v \\ \\\\ 0 & \\ldots & 0 & 1 \\end{array} \\right] \\begin{bmatrix} \\mathrm p \\\\ 1 \\end{bmatrix}\n$$\n\n## Аффинные преобразования\n\n**Сдвиг** на вектор трансляции $t = (t_x, t_y)$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} 1 &  0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf T(t_x, t_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1x + 0y + t_x1 \\\\ 0x + 1y + t_y1 \\\\ 0x + 0y + 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix},\n$$\n\n**Масштабирование** с коэффициентами $s_x, s_y$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} s_x &  0 & 0 \\\\ 0 & s_y  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf S(s_x, s_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x s_x \\\\ y s_y \\\\ 1 \\end{bmatrix},\n$$\n\n## Аффинные преобразования\n\n**Поворот** на угол $\\theta$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 0 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} \\cos \\theta &  -\\sin \\theta & 0 \\\\ \\sin \\theta & \\cos \\theta  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf R(\\theta)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta \\\\ x \\sin \\theta + y \\cos \\theta \\\\ 1 \\end{bmatrix},\n$$\n\n**Комбинации преобразований**. Например, чтобы *повернуть относительно точки* $r = (x_r, y_r)$ *на угол* $\\theta$, необходимо преобразование следующего вида:\n\n$$\n\\textrm p' =  \\mathbf T(x_r, y_r) \\mathbf R(\\theta) \\mathbf T(-x_r, -y_r) \\mathrm p\n$$\n\n::: callout-note\n## Обратите внимание\n\nЕсли точка $\\mathrm p$ записана в столбик, то преобразования выполняются (и читаются) *справа налево*.\n:::\n\n## Направление вектора\n\nДля определения направления вектора $\\mathbf u = (x, y)$ в диапазоне от $-\\pi$ до $\\pi$ используется функция $\\mathrm{atan2}$:\n\n::: columns\n::: {.column width=\"70%\"}\n$$\n\\operatorname{atan2}(y, x) =\\begin{cases} \\arctan\\left(\\frac y x\\right) &\\text{если } x > 0, \\\\[5mu] \\arctan\\left(\\frac y x\\right) + \\pi &\\text{если } x < 0 \\text{ и } y \\ge 0, \\\\[5mu] \\arctan\\left(\\frac y x\\right) - \\pi &\\text{если } x < 0 \\text{ и } y < 0, \\\\[5mu] +\\frac{\\pi}{2} &\\text{если } x = 0 \\text{ и } y > 0, \\\\[5mu] -\\frac{\\pi}{2} &\\text{если } x = 0 \\text{ и } y < 0, \\\\[5mu] \\text{undefined} &\\text{если } x = 0 \\text{ и } y = 0.\\end{cases}\n$$\n:::\n\n::: {.column width=\"30%\"}\n![](images/atan2.svg){width=\"100%\"}\n:::\n:::\n\n## **Мин. по площади огр. прямоугольник**\n\n::: columns\n::: {.column width=\"50%\"}\nЯвляется наименьшим по площади среди всех прямоугольников, охватывающих данное множество точек\n\nСогласно теореме **Фримена-Шапира** [@Freeman:1975] одна из сторон такого прямоугольника должна касаться его выпуклой оболочки.\n\n::: callout-tip\n## Вычисление\n\nРезультат теоремы Фримена-Шапира позволяет проверить всего лишь $n$ прямоугольников, где $n$ --- число сторон в выпуклой оболочке.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/minimum_area_rectangle.svg){width=\"100%\"}\n:::\n:::\n\n## **Мин. по площади огр. прямоугольник**\n\nПусть выпуклая оболочка состоит из $n$ вершин $q_i = (x_i, y_i),~i = 0...n-1$. Введем переменные $k=0$ и $S_{\\min} = +\\infty$. Тогда в цикле для каждого $j$ от $0$ до $n-2$:\n\n1.  Вычислить направление $\\gamma_j = \\texttt{atan2}(y_{j+1} - y_j,~x_{j+1} - x_j)$ для вектора $\\overrightarrow{q_j q_{j+1}}$.\n\n2.  Повернуть координаты всех точек оболочки на угол $-\\gamma_j$: $\\mathrm q_{ij} = \\mathbf R(-\\gamma_j)\\mathrm q_i = (x_{ij}, y_{ij}),~i = 0...n-1$\n\n3.  Вычислить площадь ограничивающего прямоугольника повернутых координат: $S_j = \\big[\\max(x_{ij})-\\min(x_{ij})\\big] \\times \\big[\\max(y_{ij}) - \\min(y_{ij})\\big]$.\n\n4.  Если $S_j < S_{\\min}$, то $S_{\\min} = S_j, ~ k = j$.\n\nПолученное значение $k$ указывает на сторону выпуклой оболочки, которой коллинеарна одна из сторон искомого прямоугольника [@toussaint:1983].\n\n## **Мин. по площади огр. прямоугольник**\n\nПосле окончания цикла можно получить координаты углов искомого прямоугольника путем поворота углов в обратном направлении:\n\n$$\nr_0 = \\mathbf R(\\gamma_k) \\begin{bmatrix} \\min(x_{ik}) \\\\ \\min(y_{ik}) \\\\ 1 \\end{bmatrix},~r_1 = \\mathbf R(\\gamma_k) \\begin{bmatrix} \\min(x_{ik}) \\\\ \\max(y_{ik}) \\\\ 1 \\end{bmatrix} \n$$\n\n$$\nr_2 = \\mathbf R(\\gamma_k) \\begin{bmatrix} \\max(x_{ik}) \\\\ \\max(y_{ik}) \\\\ 1 \\end{bmatrix},~r_3 = \\mathbf R(\\gamma_k) \\begin{bmatrix} \\max(x_{ik}) \\\\ \\min(y_{ik}) \\\\ 1 \\end{bmatrix} \n$$\n\n::: callout-note\n## Обратите внимание\n\nМинимальный по площади ограничивающий прямоугольник нельзя описать координатами двух углов --- требуется указание как минимум трёх.\n:::\n\n## Библиография\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}