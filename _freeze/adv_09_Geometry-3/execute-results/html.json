{
  "hash": "a89fc125e26829935470f9069cca19e7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Геометрические операции — III\"\nsubtitle: \"Геоинформатика I. Базы пространственных данных\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Геоинформатика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Основные операции\n\n::: columns\n::: {.column width=\"50%\"}\n1.  Расстояния между объектами\n2.  Периметр линии\n3.  Площадь полигона\n4.  Точка относительно прямой\n5.  Точка относительно отрезка\n6.  Пересечение отрезков\n7.  Точка в полигоне\n8.  Ограничивающий прямоугольник\n9.  Выпуклая оболочка\n10. Минимальный прямоугольник\n:::\n\n::: {.column width=\"50%\"}\n1.  Пересечение множества отрезков\n2.  **Оверлей полигонов**\n3.  **Слияние линий и полигонов**\n4.  **Полигонизация линий**\n5.  **Буферная зона**\n6.  Триангуляция Делоне\n7.  Диаграмма Вороного\n8.  Скелет и срединная ось полигона\n9.  Центроид и точка на поверхности\n10. Вогнутая оболочка\n:::\n:::\n\n## Разбиение множества\n\nРазбиение множества\n\n:   Представление множества в виде объединения произвольного числа попарно неперескающихся непустых подмножеств\n\n::: columns\n::: {.column width=\"70%\"}\nСемейство множеств $S = \\{S_\\alpha\\}$, где $\\alpha \\in A$ --- множество индексов, является разбиением множества $X$, если:\n\n-   $S$ не содержит пустого множества: $\\varnothing \\notin S$\n\n-   Объединение множеств, входящих в $S$, равно $X$:\n\n    $$\n    \\bigcup S_\\alpha = X\n    $$\n\n-   Пересечение любых различных множеств $S$ пусто:\n\n    $$\n    \\forall~\\alpha,\\beta \\in A,~\\alpha \\neq \\beta \\Longrightarrow S_\\alpha \\cap S_\\beta = \\varnothing\n    $$\n:::\n\n::: {.column width=\"30%\"}\n![](images/set_subdivision.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение плоскости\n\n::: columns\n::: {.column width=\"60%\"}\n::: callout-warning\n## Проблема\n\nПлоскость нельзя разбить множествами, которые являются *замыканиями* (включают собственную границу), т.к. в этом случае они будут пересекаться.\n:::\n\n::: callout-tip\n## Решение\n\nПредставить разбиение в виде совокупности *вершин*, *ребер* и *граней*. Эти подмножества являются *открытыми*: ребра не включают вершины, а грани не включают вершины и ребра.\n:::\n\n$$S = V \\bigcup E \\bigcup F,$$\n\nгде подмножества $V = \\{v_i\\}$ --- вершины, $E = \\{e_j\\}$ --- ребра, $F = \\{f_k\\}$ --- грани.\n:::\n\n::: {.column width=\"40%\"}\n![](images/set_subdivision_details.svg){width=\"100%\"}\n:::\n:::\n\n## Полуребра\n\nПри обработке разбиений удобно представить каждое ребро $e_j$ в виде двух полуребер $\\vec{e}_{j,0}$ и $\\vec{e}_{j,1}$, имеющих противоположные направления.\n\n::: columns\n::: {.column width=\"70%\"}\n1.  Полуребра называются *близнецами*:\n\n    $$\n    \\vec{e}_{j,0} = \\texttt{twin}(\\vec{e}_{j,1});~\\vec{e}_{j,1} = \\texttt{twin}(\\vec{e}_{j,0})\n    $$\n\n2.  Каждое полуребро входит в состав границы только одной грани.\n\n3.  Полуребро направлено таким образом, что грань находится *слева* от него.\n\n    -   полуребра *внешних* границ упорядочены *против* часовой стрелки;\n\n    -   полуребра *внутренних* границ (дырок) упорядочены *по* часовой стрелке.\n:::\n\n::: {.column width=\"30%\"}\n![](images/halfedges.svg){width=\"100%\"}\n:::\n:::\n\n## Двусвязный список ребер\n\nСтруктура данных $D$, которая опирается на следующие классы объектов:\n\n::: columns\n::: {.column width=\"75%\"}\n**Вершина** $v$\n\n|                  |                                              |\n|------------------|----------------------------------------------|\n| $(x,y)$          | координаты                                   |\n| $\\texttt{hedge}$ | полуребро, для которого $v$ является началом |\n\n**Грань** $f$\n\n|                  |                                                          |\n|------------------|------------------------------------------------------|\n| $\\texttt{outer}$ | любое полуребро внешней границы                          |\n| $\\texttt{inner}$ | список любых полуребер дырок (по одному на каждую дырку) |\n:::\n\n::: {.column width=\"25%\"}\n![](images/vertex_face.svg){width=\"90%\"}\n:::\n:::\n\n::: callout-note\n## Особенности\n\nДля *неограниченной* области $\\texttt{outer} = \\varnothing$, для полигона *без дырок* $\\texttt{inner} = \\varnothing$\n:::\n\n## Двусвязный список ребер\n\n::: columns\n::: {.column width=\"70%\"}\n**Полуребро** $\\overrightarrow e$\n\n|                   |                                        |\n|-------------------|----------------------------------------|\n| $\\texttt{origin}$ | вершина, являющаяся началом полуребра  |\n| $\\texttt{twin}$   | полуребро-близнец                      |\n| $\\texttt{face}$   | инцидентная грань                      |\n| $\\texttt{next}$   | следующее полуребро в $\\texttt{face}$  |\n| $\\texttt{prev}$   | предыдущее полуребро в $\\texttt{face}$ |\n\n::: callout-note\n## Объем данных\n\nРазмер вершины и полуребра фиксирован. Размер грани $\\sim$ кол-во дырок.\n:::\n\n::: callout-tip\n## А конец полуребра?\n\nКонец полуребра можно получить как $\\texttt{origin}(\\texttt{twin}(\\overrightarrow{e}))$\n:::\n:::\n\n::: {.column width=\"30%\"}\n![](images/halfedge.svg){width=\"100%\"}\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-msmall width=\"55%\"}\n| vertex | coords | hedge    |\n|--------|--------|----------|\n| `0`    | `x,y`  | `(6,1)`  |\n| `1`    | `x,y`  | `(7,0)`  |\n| `2`    | `x,y`  | `(1,1)`  |\n| `3`    | `x,y`  | `(10,0)` |\n| `4`    | `x,y`  | `(9,0)`  |\n| `5`    | `x,y`  | `(2,1)`  |\n| `6`    | `x,y`  | `(11,0)` |\n| `7`    | `x,y`  | `(10,1)` |\n| `8`    | `x,y`  | `(6,0)`  |\n| `9`    | `x,y`  | `(4,1)`  |\n| `10`   | `x,y`  | `(8,0)`  |\n| `11`   | `x,y`  | `(8,1)`  |\n| `12`   | `x,y`  | `(3,1)`  |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"55%\"}\n| face | outer    | inner               |\n|------|----------|---------------------|\n| `0`  | `NULL`   | `(0,0),(7,1),(8,0)` |\n| `1`  | `(3,1)`  | `NULL`              |\n| `2`  | `(9,1)`  | `(12,0)`            |\n| `3`  | `(11,1)` | `NULL`              |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-vsmall width=\"55%\"}\n| hedge   | origin | twin    | face | next    | prev    |\n|---------|--------|---------|------|---------|---------|\n| `(0,0)` | `0`    | `(0,1)` | `0`  | `(1,0)` | `(6,0)` |\n| `(0,1)` | `4`    | `(0,0)` | `2`  | `(6,1)` | `(9,1)` |\n| `(1,0)` | `4`    | `(1,1)` | `0`  | `(1,1)` | `(0,0)` |\n| `(1,1)` | `2`    | `(1,0)` | `0`  | `(2,0)` | `(1,0)` |\n| `(2,0)` | `4`    | `(2,1)` | `0`  | `(3,0)` | `(1,1)` |\n| `(2,1)` | `5`    | `(2,0)` | `1`  | `(9,0)` | `(3,1)` |\n| `(3,0)` | `5`    | `(3,1)` | `0`  | `(4,0)` | `(2,0)` |\n| `(3,1)` | `12`   | `(3,0)` | `1`  | `(2,1)` | `(4,1)` |\n| `(4,0)` | `12`   | `(4,1)` | `0`  | `(5,0)` | `(3,0)` |\n| `(4,1)` | `9`    | `(4,0)` | `1`  | `(3,1)` | `(9,0)` |\n| `(5,0)` | `9`    | `(5,1)` | `0`  | `(6,0)` | `(4,0)` |\n| `(5,1)` | `8`    | `(5,0)` | `2`  | `(9,1)` | `(6,1)` |\n| `(6,0)` | `8`    | `(6,1)` | `0`  | `(0,0)` | `(5,0)` |\n| `(6,1)` | `0`    | `(6,0)` | `2`  | `(5,1)` | `(0,1)` |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-vsmall width=\"55%\"}\n| hedge    | origin | twin     | face | next     | prev     |\n|----------|--------|----------|------|----------|----------|\n| `(7,0)`  | `1`    | `(7,1)`  | `0`  | `(7,1)`  | `(7,1)`  |\n| `(7,1)`  | `1`    | `(7,0)`  | `0`  | `(7,0)`  | `(7,0)`  |\n| `(8,0)`  | `10`   | `(8,1)`  | `0`  | `(8,1)`  | `(8,1)`  |\n| `(8,1)`  | `11`   | `(8,0)`  | `0`  | `(8,0)`  | `(8,0)`  |\n| `(9,0)`  | `4`    | `(9,1)`  | `1`  | `(4,1)`  | `(2,1)`  |\n| `(9,1)`  | `9`    | `(9,0)`  | `2`  | `(0,1)`  | `(5,1)`  |\n| `(10,0)` | `3`    | `(10,1)` | `2`  | `(12,0)` | `(11,0)` |\n| `(10,1)` | `7`    | `(10,0)` | `3`  | `(11,1)` | `(12,1)` |\n| `(11,0)` | `6`    | `(11,1)` | `2`  | `(10,0)` | `(12,0)` |\n| `(11,1)` | `3`    | `(11,0)` | `3`  | `(12,1)` | `(10,1)` |\n| `(12,0)` | `7`    | `(12,1)` | `2`  | `(11,0)` | `(10,0)` |\n| `(12,1)` | `6`    | `(12,0)` | `3`  | `(10,1)` | `(11,1)` |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"55%\"}\n::: callout-important\n## Ребра нулевой длины\n\nВ строгом смысле слова ребра `(7,0)` и `(7,1)` в разбиение не входят, т.к. имеют нулевую длину (согласно определению, разбиение не может включать пустое множество). Однако по их наличию в структуре данных можно идентифицировать изолированную вершину: $\\texttt{origin}(\\vec e) = \\texttt{origin}(\\texttt{twin}(\\vec e))$\n:::\n\n::: callout-tip\n## Изолированные компоненты\n\nИзолированные вершины и изолированные незамкнутые последовательности ребер (например, одиночное ребро $e_8$) всегда соответствуют дыркам в окружающих гранях.\n:::\n\n::: callout-note\n## Внутренность дырки\n\nВнутренность дырки ($f_3$) является полноценной гранью, однако у нее нет информации о принадлежности полигону.\n:::\n:::\n:::\n\n## Оверлей\n\n::: columns\n::: {.column width=\"50%\"}\n**Оверлей** двух разбиений $S_1$ и $S_2$ --- это разбиение $O(S_1, S_2)$, в котором все грани $f$ являются\n\n-   *максимальными* (по площади);\n\n-   *открытыми* (не включающими ребра и вершины);\n\n-   *линейно связными* (представимыми в виде полигона)\n\nподмножествами пересечений $f_1 \\cap f_2$ каких-либо граней $f_1 \\in S_1$, $f_2 \\in S_2$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/overlay_1.svg){width=\"100%\"}\n:::\n:::\n\n## Оверлей\n\n::: columns\n::: {.column width=\"50%\"}\n**Оверлей** двух разбиений $S_1$ и $S_2$ --- это разбиение $O(S_1, S_2)$, в котором все грани $f$ являются\n\n-   *максимальными* (по площади);\n\n-   *открытыми* (не включающими ребра и вершины);\n\n-   *линейно связными* (представимыми в виде полигона)\n\nподмножествами пересечений $f_1 \\cap f_2$ каких-либо граней $f_1 \\in S_1$, $f_2 \\in S_2$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/overlay_2.svg){width=\"100%\"}\n:::\n:::\n\n## Граф\n\n**Простой граф** $G(V,E)$ --- совокупность множества вершин $V = \\{v_1, v_2, ...\\}$ и множества ребер $E$ [@newman2018].\n\n::: columns\n::: {.column width=\"50%\"}\n-   $E$ состоит из упорядоченных пар элементов множества вершин:\n\n    $$\n    e_{ij} = \\{v_i, v_j \\},~ i \\neq j\n    $$\n\n-   $V$ не пусто;\n\n-   $E$ может быть пустым;\n\n-   не все комбинации $\\{v_i, v_j \\}$ могут входить в $E$.\n\nМаксимальный связный подграф называется **компонентой** графа.\n:::\n\n::: {.column width=\"50%\"}\n![](images/graph.svg){width=\"100%\"}\n:::\n:::\n\n## Оверлей --- алгоритм [@deberg:2008]\n\n**Вход**: планарные разбиения $S_1$ и $S_2$ в виде двусвязных списков $D_1$ и $D_2$\n\n**Выход**: оверлей $S_1$ и $S_2$ в виде двусвязного списка $D$.\n\n1.  Объединить списки простым копированием: $D = D_1 \\cup D_2$, сохранив информацию о принадлежности вершин, ребер и граней исходным разбиениям.\n\n2.  Вычислить пересечения между ребрами внутри $D$, используя алгоритм сканирующей линии Бентли-Оттмана.\n\n    -   если событие включает ребра из $D_1$ и $D_2$, обновить ребра в $D$;\n\n    *После этого шага* $D$ *имеет корректный перечень вершин и полуребер для* $O(S_1, S_2)$*, но не граней*.\n\n3.  Вычислить все границы (замкнутые последовательности полуребер) в $D$.\n\n4.  Связать внешние границы и относящиеся к ним внутренние в виде графа $G$.\n\n5.  Для каждой компоненты $G$ создать грань в $D$.\n\n## Объединение разбиений\n\nОбъединить списки простым копированием: $D = D_1 \\cup D_2$, сохранив информацию о принадлежности вершин, ребер и граней исходным разбиениям.\n\n![](images/overlay_sweep1.svg){width=\"100%\"}\n\n## Обновление двусвязного списка\n\nПри появлении пересечения необходимо добавить вершину, а также новые полуребра, для которых она будет $\\texttt{origin}$. Для старых полуребер обновить $\\texttt{next}$.\n\n![](images/overlay_sweep.svg){width=\"100%\"}\n\n## Обновление двусвязного списка\n\nПри появлении пересечения необходимо добавить вершину, а также новые полуребра, для которых она будет $\\texttt{origin}$. Для старых полуребер обновить $\\texttt{next}$.\n\n![](images/overlay_sweep3.svg){width=\"100%\"}\n\n## Вычисление циклов\n\nВычислить все границы (замкнутые последовательности полуребер) в $D$. На рисунке показаны циклы, соответствующие внешним границам\n\n![](images/overlay_sweep4.svg){width=\"100%\"}\n\n## Сборка граней\n\nЗамкнутые последовательности собираются в грани.\n\n![](images/overlay_sweep5.svg){width=\"100%\"}\n\n## Булевы операции\n\n**Оверлей** полигонов часто используется для выполнения *булевых* операций.\n\n![](images/overlay.svg){width=\"100%\"}\n\n*Объединение*: грани, образованные $A$ или $B$.\n\n*Пересечение*: грани, образованные $A$ и $B$.\n\n## Слияние полигонов\n\n**Слияние** --- это объединение объектов с сохранением их размерности.\n\nОсуществляется оверлей полигонов, но перед поиском циклов удаляются ребра и вершины, принадлежащие *только* удаляемым объектам.\n\n![](images/merge.svg){width=\"100%\"}\n\n## Полигонизация линий\n\n**Полигонизация линий** --- это преобразование множества линий в полигоны.\n\nВ планарном разбиении, определяемом множеством линий, сохраняются только грани конечного размера.\n\n![](images/polygonization.svg){width=\"100%\"}\n\n## Буферные зоны\n\n**Буферная зона** --- это множество точек, располагающихся в пределах заданного расстояния относительно объекта.\n\n::: columns\n::: {.column width=\"40%\"}\n-   буфер точки представляет собой диск;\n\n-   буфер полигона может быть положительным и отрицательным;\n\n-   буфер точки или линии всегда положительный.\n:::\n\n::: {.column width=\"60%\"}\n![](images/buffering.svg){width=\"55%\"}\n:::\n:::\n\n::: callout-tip\n## Применение\n\nИспользуются при анализе влияния. Например, определения водоохранных зон.\n:::\n\n## Буферная зона линии\n\n**Буферная зона линии** получается путем *слияния* прямоугольников и дисков заданной ширины (радиуса), построенных относительно ребер и вершин.\n\n![](images/buffer_line.svg){width=\"100%\"}\n\n*Самостоятельная работа:* формализуйте получение координат прямоугольников\n\n## Буферная зона полигона (положительная)\n\n**Положительная буферная зона полигона** получается путем *слияния* полигона и буферной зоны его границы.\n\n![](images/buffer_poly.svg){width=\"80%\"}\n\n## Буферная зона полигона (отрицательная)\n\n**Отрицательная буферная зона полигона** получается путем *вычитания* из полигона буферной зоны его границы.\n\n![](images/buffer_poly_neg.svg){width=\"80%\"}\n\n## Вопросы на подумать\n\n::: columns\n::: {.column width=\"70%\"}\nКакие из приведенных равенств всегда выполняются для планарного разбиения?\n\n$$\n\\begin{aligned}\n\\texttt{twin}(\\texttt{twin}(\\overrightarrow e)) &= \\overrightarrow e\\\\~\\\\\n\\texttt{next}(\\texttt{prev}(\\overrightarrow e)) &= \\overrightarrow e\\\\~\\\\\n\\texttt{twin}(\\texttt{prev}(\\texttt{twin}(\\overrightarrow e))) &= \\texttt{next}(\\overrightarrow e)\\\\~\\\\\n\\texttt{face}(\\overrightarrow e) &= \\texttt{face}(\\texttt{next}(\\overrightarrow e))\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"30%\"}\n![](images/rick_thinking.png){width=\"100%\"}\n:::\n:::\n\n## Библиография\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}