{
  "hash": "1a1d951122a414602fe53f11fef3fb54",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Геометрические операции — III\"\nsubtitle: \"Геоинформатика I. Базы пространственных данных\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Геоинформатика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Основные операции\n\n::: columns\n::: {.column width=\"50%\"}\n1.  Расстояния между объектами\n2.  Периметр линии\n3.  Площадь полигона\n4.  Точка относительно прямой\n5.  Точка относительно отрезка\n6.  Пересечение отрезков\n7.  Точка в полигоне\n8.  Направление вектора\n9.  Ограничивающий прямоугольник\n10. Выпуклая оболочка\n11. Минимальный прямоугольник\n:::\n\n::: {.column width=\"50%\"}\n1.  **Пересечение множества отрезков**\n2.  **Оверлей**\n3.  **Cлияние полигонов**\n4.  **Полигонизация линий**\n5.  **Буферная зона**\n6.  **Триангуляция Делоне**\n7.  **Диаграмма Вороного**\n8.  **Вогнутая оболочка**\n9.  **Триангуляция полигона**\n10. **Центроид полигона**\n11. **Срединная ось полигона**\n:::\n:::\n\n## Разбиение множества\n\nРазбиение множества\n\n:   Представление множества в виде объединения произвольного числа попарно неперескающихся непустых подмножеств\n\n::: columns\n::: {.column width=\"70%\"}\nСемейство множеств $S = \\{S_\\alpha\\}$, где $\\alpha \\in A$ --- множество индексов, является разбиением множества $X$, если:\n\n-   $S$ не содержит пустого множества: $\\varnothing \\notin S$\n\n-   Объединение множеств, входящих в $S$, равно $X$:\n\n    $$\n    \\bigcup S_\\alpha = X\n    $$\n\n-   Пересечение любых различных множеств $S$ пусто:\n\n    $$\n    \\forall~\\alpha,\\beta \\in A,~\\alpha \\neq \\beta \\Longrightarrow S_\\alpha \\cap S_\\beta = \\varnothing\n    $$\n:::\n\n::: {.column width=\"30%\"}\n![](images/set_subdivision.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение плоскости\n\n::: columns\n::: {.column width=\"60%\"}\n::: callout-warning\n## Проблема\n\nПлоскость нельзя разбить множествами, которые являются *замыканиями* (включают собственную границу), т.к. в этом случае они будут пересекаться.\n:::\n\n::: callout-tip\n## Решение\n\nПредставить разбиение в виде совокупности *вершин*, *ребер* и *граней*. Эти подмножества являются *открытыми*: ребра не включают вершины, а грани не включают вершины и ребра.\n:::\n\n$$S = V \\bigcup E \\bigcup F,$$\n\nгде подмножества $V = \\{v_i\\}$ --- вершины, $E = \\{e_j\\}$ --- ребра, $F = \\{f_k\\}$ --- грани.\n:::\n\n::: {.column width=\"40%\"}\n![](images/set_subdivision_details.svg){width=\"100%\"}\n:::\n:::\n\n## Полуребра\n\nПри обработке разбиений удобно представить каждое ребро $e_j$ в виде двух полуребер $\\vec{e}_{j,0}$ и $\\vec{e}_{j,1}$, имеющих противоположные направления.\n\n::: columns\n::: {.column width=\"70%\"}\n1.  Полуребра называются *близнецами*:\n\n    $$\n    \\vec{e}_{j,0} = \\texttt{twin}(\\vec{e}_{j,1});~\\vec{e}_{j,1} = \\texttt{twin}(\\vec{e}_{j,0})\n    $$\n\n2.  Каждое полуребро входит в состав границы только одной грани.\n\n3.  Полуребро направлено таким образом, что грань находится *слева* от него.\n\n    -   полуребра *внешних* границ упорядочены *против* часовой стрелки;\n\n    -   полуребра *внутренних* границ (дырок) упорядочены *по* часовой стрелке.\n:::\n\n::: {.column width=\"30%\"}\n![](images/halfedges.svg){width=\"100%\"}\n:::\n:::\n\n## Двусвязный список ребер\n\nСтруктура данных $D$, которая опирается на следующие классы объектов:\n\n::: columns\n::: {.column width=\"75%\"}\n**Вершина** $v$\n\n|                  |                                              |\n|------------------|----------------------------------------------|\n| $(x,y)$          | координаты                                   |\n| $\\texttt{hedge}$ | полуребро, для которого $v$ является началом |\n\n**Грань** $f$\n\n|                  |                                                          |\n|---------------------|---------------------------------------------------|\n| $\\texttt{outer}$ | любое полуребро внешней границы                          |\n| $\\texttt{inner}$ | список любых полуребер дырок (по одному на каждую дырку) |\n:::\n\n::: {.column width=\"25%\"}\n![](images/vertex_face.svg){width=\"90%\"}\n:::\n:::\n\n::: callout-note\n## Особенности\n\nДля *неограниченной* области $\\texttt{outer} = \\varnothing$, для полигона *без дырок* $\\texttt{inner} = \\varnothing$\n:::\n\n## Двусвязный список ребер\n\n::: columns\n::: {.column width=\"70%\"}\n**Полуребро** $\\overrightarrow e$\n\n|                   |                                        |\n|-------------------|----------------------------------------|\n| $\\texttt{origin}$ | вершина, являющаяся началом полуребра  |\n| $\\texttt{twin}$   | полуребро-близнец                      |\n| $\\texttt{face}$   | инцидентная грань                      |\n| $\\texttt{next}$   | следующее полуребро в $\\texttt{face}$  |\n| $\\texttt{prev}$   | предыдущее полуребро в $\\texttt{face}$ |\n\n::: callout-note\n## Объем данных\n\nРазмер вершины и полуребра фиксирован. Размер грани $\\sim$ кол-во дырок.\n:::\n\n::: callout-tip\n## А конец полуребра?\n\nКонец полуребра можно получить как $\\texttt{origin}(\\texttt{twin}(\\overrightarrow{e}))$\n:::\n:::\n\n::: {.column width=\"30%\"}\n![](images/halfedge.svg){width=\"100%\"}\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-msmall width=\"55%\"}\n| vertex | coords | hedge    |\n|--------|--------|----------|\n| `0`    | `x,y`  | `(6,1)`  |\n| `1`    | `x,y`  | `(7,0)`  |\n| `2`    | `x,y`  | `(1,1)`  |\n| `3`    | `x,y`  | `(10,0)` |\n| `4`    | `x,y`  | `(9,0)`  |\n| `5`    | `x,y`  | `(2,1)`  |\n| `6`    | `x,y`  | `(11,0)` |\n| `7`    | `x,y`  | `(10,1)` |\n| `8`    | `x,y`  | `(6,0)`  |\n| `9`    | `x,y`  | `(4,1)`  |\n| `10`   | `x,y`  | `(8,0)`  |\n| `11`   | `x,y`  | `(8,1)`  |\n| `12`   | `x,y`  | `(3,1)`  |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"55%\"}\n| face | outer    | inner               |\n|------|----------|---------------------|\n| `0`  | `NULL`   | `(0,0),(7,1),(8,0)` |\n| `1`  | `(3,1)`  | `NULL`              |\n| `2`  | `(9,1)`  | `(12,0)`            |\n| `3`  | `(11,1)` | `NULL`              |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-vsmall width=\"55%\"}\n| hedge   | origin | twin    | face | next    | prev    |\n|---------|--------|---------|------|---------|---------|\n| `(0,0)` | `0`    | `(0,1)` | `0`  | `(1,0)` | `(6,0)` |\n| `(0,1)` | `4`    | `(0,0)` | `2`  | `(6,1)` | `(9,1)` |\n| `(1,0)` | `4`    | `(1,1)` | `0`  | `(1,1)` | `(0,0)` |\n| `(1,1)` | `2`    | `(1,0)` | `0`  | `(2,0)` | `(1,0)` |\n| `(2,0)` | `4`    | `(2,1)` | `0`  | `(3,0)` | `(1,1)` |\n| `(2,1)` | `5`    | `(2,0)` | `1`  | `(9,0)` | `(3,1)` |\n| `(3,0)` | `5`    | `(3,1)` | `0`  | `(4,0)` | `(2,0)` |\n| `(3,1)` | `12`   | `(3,0)` | `1`  | `(2,1)` | `(4,1)` |\n| `(4,0)` | `12`   | `(4,1)` | `0`  | `(5,0)` | `(3,0)` |\n| `(4,1)` | `9`    | `(4,0)` | `1`  | `(3,1)` | `(9,0)` |\n| `(5,0)` | `9`    | `(5,1)` | `0`  | `(6,0)` | `(4,0)` |\n| `(5,1)` | `8`    | `(5,0)` | `2`  | `(9,1)` | `(6,1)` |\n| `(6,0)` | `8`    | `(6,1)` | `0`  | `(0,0)` | `(5,0)` |\n| `(6,1)` | `0`    | `(6,0)` | `2`  | `(5,1)` | `(0,1)` |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column .table-vsmall width=\"55%\"}\n| hedge    | origin | twin     | face | next     | prev     |\n|----------|--------|----------|------|----------|----------|\n| `(7,0)`  | `1`    | `(7,1)`  | `0`  | `(7,1)`  | `(7,1)`  |\n| `(7,1)`  | `1`    | `(7,0)`  | `0`  | `(7,0)`  | `(7,0)`  |\n| `(8,0)`  | `10`   | `(8,1)`  | `0`  | `(8,1)`  | `(8,1)`  |\n| `(8,1)`  | `11`   | `(8,0)`  | `0`  | `(8,0)`  | `(8,0)`  |\n| `(9,0)`  | `4`    | `(9,1)`  | `1`  | `(4,1)`  | `(2,1)`  |\n| `(9,1)`  | `9`    | `(9,0)`  | `2`  | `(0,1)`  | `(5,1)`  |\n| `(10,0)` | `3`    | `(10,1)` | `2`  | `(12,0)` | `(11,0)` |\n| `(10,1)` | `7`    | `(10,0)` | `3`  | `(11,1)` | `(12,1)` |\n| `(11,0)` | `6`    | `(11,1)` | `2`  | `(10,0)` | `(12,0)` |\n| `(11,1)` | `3`    | `(11,0)` | `3`  | `(12,1)` | `(10,1)` |\n| `(12,0)` | `7`    | `(12,1)` | `2`  | `(11,0)` | `(10,0)` |\n| `(12,1)` | `6`    | `(12,0)` | `3`  | `(10,1)` | `(11,1)` |\n:::\n:::\n\n## Двусвязный список ребер (пример)\n\n::: columns\n::: {.column width=\"45%\"}\n![](images/edge_list.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"55%\"}\n::: callout-important\n## Ребра нулевой длины\n\nВ строгом смысле слова ребра `(7,0)` и `(7,1)` в разбиение не входят, т.к. имеют нулевую длину (согласно определению, разбиение не может включать пустое множество). Однако по их наличию в структуре данных можно идентифицировать изолированную вершину: $\\texttt{origin}(\\vec e) = \\texttt{origin}(\\texttt{twin}(\\vec e))$\n:::\n\n::: callout-tip\n## Изолированные компоненты\n\nИзолированные вершины и изолированные незамкнутые последовательности ребер (например, одиночное ребро $e_8$) всегда соответствуют дыркам в окружающих гранях.\n:::\n\n::: callout-note\n## Внутренность дырки\n\nВнутренность дырки ($f_3$) является полноценной гранью, однако у нее нет информации о принадлежности полигону.\n:::\n:::\n:::\n\n## Оверлей\n\n::: columns\n::: {.column width=\"50%\"}\n**Оверлей** двух разбиений $S_1$ и $S_2$ --- это разбиение $O(S_1, S_2)$, в котором все грани $f$ являются\n\n-   *максимальными* (по площади);\n\n-   *открытыми* (не включающими ребра и вершины);\n\n-   *линейно связными* (представимыми в виде полигона)\n\nподмножествами пересечений $f_1 \\cap f_2$ каких-либо граней $f_1 \\in S_1$, $f_2 \\in S_2$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/overlay_1.svg){width=\"100%\"}\n:::\n:::\n\n## Оверлей\n\n::: columns\n::: {.column width=\"50%\"}\n**Оверлей** двух разбиений $S_1$ и $S_2$ --- это разбиение $O(S_1, S_2)$, в котором все грани $f$ являются\n\n-   *максимальными* (по площади);\n\n-   *открытыми* (не включающими ребра и вершины);\n\n-   *линейно связными* (представимыми в виде полигона)\n\nподмножествами пересечений $f_1 \\cap f_2$ каких-либо граней $f_1 \\in S_1$, $f_2 \\in S_2$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/overlay_2.svg){width=\"100%\"}\n:::\n:::\n\n## Граф\n\n**Простой граф** $G(V,E)$ --- совокупность множества вершин $V = \\{v_1, v_2, ...\\}$ и множества ребер $E$ [@newman2018].\n\n::: columns\n::: {.column width=\"50%\"}\n-   $E$ состоит из упорядоченных пар элементов множества вершин:\n\n    $$\n    e_{ij} = \\{v_i, v_j \\},~ i \\neq j\n    $$\n\n-   $V$ не пусто;\n\n-   $E$ может быть пустым;\n\n-   не все комбинации $\\{v_i, v_j \\}$ могут входить в $E$.\n\nМаксимальный связный подграф называется **компонентой** графа.\n:::\n\n::: {.column width=\"50%\"}\n![](images/graph.svg){width=\"100%\"}\n:::\n:::\n\n## Оверлей --- алгоритм [@deberg:2008]\n\n**Вход**: планарные разбиения $S_1$ и $S_2$ в виде двусвязных списков $D_1$ и $D_2$\n\n**Выход**: оверлей $S_1$ и $S_2$ в виде двусвязного списка $D$.\n\n1.  Объединить списки простым копированием: $D = D_1 \\cup D_2$, сохранив информацию о принадлежности вершин, ребер и граней исходным разбиениям.\n\n2.  Вычислить пересечения между ребрами внутри $D$, используя алгоритм сканирующей линии Бентли-Оттмана.\n\n    -   если событие включает ребра из $D_1$ и $D_2$, обновить ребра в $D$;\n\n    *После этого шага* $D$ *имеет корректный перечень вершин и полуребер для* $O(S_1, S_2)$*, но не граней*.\n\n3.  Вычислить все границы (замкнутые последовательности полуребер) в $D$.\n\n4.  Связать внешние границы и относящиеся к ним внутренние в виде графа $G$.\n\n5.  Для каждой компоненты $G$ создать грань в $D$.\n\n## Объединение разбиений\n\nОбъединить списки простым копированием: $D = D_1 \\cup D_2$, сохранив информацию о принадлежности вершин, ребер и граней исходным разбиениям.\n\n![](images/overlay_sweep1.svg){width=\"100%\"}\n\n## Обновление двусвязного списка\n\nПри появлении пересечения необходимо добавить вершину, а также новые полуребра, для которых она будет $\\texttt{origin}$. Для старых полуребер обновить $\\texttt{next}$.\n\n![](images/overlay_sweep.svg){width=\"100%\"}\n\n## Обновление двусвязного списка\n\nПри появлении пересечения необходимо добавить вершину, а также новые полуребра, для которых она будет $\\texttt{origin}$. Для старых полуребер обновить $\\texttt{next}$.\n\n![](images/overlay_sweep3.svg){width=\"100%\"}\n\n## Вычисление циклов\n\nВычислить все границы (замкнутые последовательности полуребер) в $D$. На рисунке показаны циклы, соответствующие внешним границам\n\n![](images/overlay_sweep4.svg){width=\"100%\"}\n\n## Сборка граней\n\nЗамкнутые последовательности собираются в грани.\n\n![](images/overlay_sweep5.svg){width=\"100%\"}\n\n## Булевы операции\n\n**Оверлей** полигонов часто используется для выполнения *булевых* операций.\n\n![](images/overlay.svg){width=\"100%\"}\n\n*Объединение*: грани, образованные $A$ или $B$.\n\n*Пересечение*: грани, образованные $A$ и $B$.\n\n## Слияние полигонов\n\n**Слияние** --- это объединение объектов с сохранением их размерности.\n\nОсуществляется оверлей полигонов, но перед поиском циклов удаляются ребра и вершины, принадлежащие *только* удаляемым объектам.\n\n![](images/merge.svg){width=\"100%\"}\n\n## Полигонизация линий\n\n**Полигонизация линий** --- это преобразование множества линий в полигоны.\n\nВ планарном разбиении, определяемом множеством линий, сохраняются только грани конечного размера.\n\n![](images/polygonization.svg){width=\"100%\"}\n\n## Буферные зоны\n\n**Буферная зона** --- это множество точек, располагающихся в пределах заданного расстояния относительно объекта.\n\n::: columns\n::: {.column width=\"40%\"}\n-   буфер точки представляет собой диск;\n\n-   буфер полигона может быть положительным и отрицательным;\n\n-   буфер точки или линии всегда положительный.\n:::\n\n::: {.column width=\"60%\"}\n![](images/buffering.svg){width=\"55%\"}\n:::\n:::\n\n::: callout-tip\n## Применение\n\nИспользуются при анализе влияния. Например, определения водоохранных зон.\n:::\n\n## Буферная зона линии\n\n**Буферная зона линии** получается путем *слияния* прямоугольников и дисков заданной ширины (радиуса), построенных относительно ребер и вершин.\n\n![](images/buffer_line.svg){width=\"100%\"}\n\n*Самостоятельная работа:* формализуйте получение координат прямоугольников\n\n## Буферная зона полигона (положительная)\n\n**Положительная буферная зона полигона** получается путем *слияния* полигона и буферной зоны его границы.\n\n![](images/buffer_poly.svg){width=\"80%\"}\n\n## Буферная зона полигона (отрицательная)\n\n**Отрицательная буферная зона полигона** получается путем *вычитания* из полигона буферной зоны его границы.\n\n![](images/buffer_poly_neg.svg){width=\"80%\"}\n\n## Вопросы на подумать\n\n::: columns\n::: {.column width=\"70%\"}\nКакие из приведенных равенств всегда выполняются для планарного разбиения?\n\n$$\n\\begin{aligned}\n\\texttt{twin}(\\texttt{twin}(\\overrightarrow e)) &= \\overrightarrow e\\\\~\\\\\n\\texttt{next}(\\texttt{prev}(\\overrightarrow e)) &= \\overrightarrow e\\\\~\\\\\n\\texttt{twin}(\\texttt{prev}(\\texttt{twin}(\\overrightarrow e))) &= \\texttt{next}(\\overrightarrow e)\\\\~\\\\\n\\texttt{face}(\\overrightarrow e) &= \\texttt{face}(\\texttt{next}(\\overrightarrow e))\n\\end{aligned}\n$$\n:::\n\n::: {.column width=\"30%\"}\n![](images/rick_thinking.png){width=\"100%\"}\n:::\n:::\n\n## Диаграмма Вороного\n\n::: columns\n::: {.column width=\"50%\"}\n**Диаграмма Вороного** $Vor(P)$ множества точек $P = \\{p_0, … p_{n-1}\\}$ --- *разбиение плоскости* такое, что точка $q$ принадлежит грани $V(p_i)$ тогда и только тогда, когда:\n\n$$\nd(q, p_i) < d(q, p_j), \\forall i \\neq j\n$$\n\n::: callout-note\n## Области и ячейки\n\nГрани диаграммы Вороного также называют областями или ячейками\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/voronoy_elements.svg){width=\"100%\"}\n:::\n:::\n\n## Элементы диаграммы Вороного\n\n**Область диаграммы Вороного** --- множество точек, удовлетворяющее условию:\n\n$$\nV(p) = \\big\\{ x \\in \\mathbb{R}^2: d(x,p) < d(x,q), \\forall q \\in P~\\backslash~p \\big\\}\n$$\n\n**Ребро диаграммы Вороного** --- множество точек, удовлетворяющее условию:\n\n$$\nV(p_0, p_1) = \\big\\{ x \\in \\mathbb{R}^2: \\big( d(x,p_0) = d(x,p_1) \\big) \\land \\big(d(x,p_0) < d(x,q) \\big), \\forall q \\neq p_0, p_1 \\big\\}\n$$\n\n**Вершина диаграммы Вороного** --- множество точек, удовлетворяющее условию:\n\n$$\nV(p_0, p_1, p_2) = \\partial V(p_0) \\cap \\partial V(p_1) \\cap \\partial V(p_2)\n$$\n\n## Триангуляция\n\nТриангуляция множества точек $P$\n\n:   Планарное разбиение, ограниченные грани которого являются треугольниками, а вершины являются точками $P$\n\n::: columns\n::: {.column width=\"50%\"}\n::: callout-note\n## Максимальное разбиение\n\nТриангуляция является максимальным разбиением в том смысле, что в нее нельзя добавить новые ребра так чтобы они не пересекали существующие\n:::\n\n::: callout-tip\n## Количество треугольников и ребер\n\nЕсли $P$ содержит $n$ точек, и его выпуклая оболочка содержит $k$ точек, то любая триангуляция $P$ содержит $2n-2-k$ треугольников и $3n-3-k$ ребер.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/TIN.svg){width=\"100%\"}\n:::\n:::\n\n## Оптимальность по углам\n\nПусть дана триангуляция $T$, включающая $m$ треугольников, имеющих углы $\\alpha$. Тогда упорядоченную по возрастанию $\\alpha$ последовательность\n\n$$A(T) := (\\alpha_0, \\alpha_1,..., \\alpha_{3m-1}),~где~\\alpha_i \\leq \\alpha_j~при~i < j$$\n\nбудем называть **угловым вектором** $T$.\n\nУгловой вектор $T$ **больше** углового вектора $T'$, если:\n\n$$\nA(T) > A(T') \\Leftrightarrow \\exists i: (\\alpha_j = \\alpha'_j~при~j < i) \\land (\\alpha_i > \\alpha'_i)\n$$\n\nТриангуляция $T$ называется оптимальной по углам, если\n\n$$\nA(T) \\geq A(T')\n$$\n\nдля всех возможных триангуляций $T'$ множества точек $P$.\n\n## Граф и триангуляция Делоне\n\nПусть дано множество точек $P = \\{p_i\\}$ и его диаграмма Вороного $Vor(P)$.\n\n**Граф Делоне** $DG(P)$ состоит из\n\n-   вершин $P$;\n\n-   ребер $E$, включающих $\\overline{p_i p_j}$, если $V(p_i, p_j) \\neq \\varnothing$.\n\n**Триангуляция Делоне** $DT(P)$ --- триангуляция, ребра которой состоят из ребер графа Делоне $DG(P)$.\n\n::: callout-note\n## Определяющее свойство\n\nТриангуляция множества точек $P$ является триангуляцией Делоне тогда и только тогда, когда диск, описанный вокруг любого треугольника, не содержит точек $P$ в своей внутренней области.\n:::\n\n::: callout-tip\n## Оптимальность\n\nЛюбая оптимальная по углам триангуляция является триангуляцией Делоне\n:::\n\n## Перестановка и легальность ребер\n\nПерестановка ребра\n\n:   Пусть ребро $e = \\overline{p_i p_j}$ инцидентно $\\triangle p_i p_j p_k$ и $\\triangle p_i p_j p_l$. Если $p_i p_k p_j p_l$ --- выпуклый четырехугольник, то перестановкой $e$ называется получение новой триангуляции $T'$, в которой $e$ заменено на $e' = \\overline{p_k p_l} = \\texttt{flip}(\\overline{p_i p_j})$\n\n::: columns\n::: {.column width=\"50%\"}\n\nНелегальное ребро\n\n:   Ребро триангуляции считается *нелегальным*, если его перестановка увеличивает минимальный угол в инцидентных треугольниках.\n\nТ.е. если углы $\\alpha_0,...\\alpha_5$ в $A(T)$ заменяются на $\\alpha'_0,...\\alpha'_5$ в $A(T')$, где\n\n$$\n\\min_{0 \\leq i \\leq 5} \\alpha_i < \\min_{0 \\leq i \\leq 5} \\alpha'_i\n$$\n:::\n\n::: {.column width=\"50%\"}\n![](images/illegal_edges.svg){width=\"65%\"}\n:::\n:::\n\n## Легальная триангуляция\n\n**Легальной** называется триангуляция, в которой все ребра легальные.\n\nПерестановка одного ребра может привести к тому, что в соседних четырехугольниках ребра перестанут быт легальными. Полная процедура требует запуска следующего алгоритма.\n\n$\\texttt{legalize_edge}(p_r, \\overline{p_i p_j}, T):$\n\n-   Если ребро $\\overline{p_i p_j}$ нелегально:\n\n    -   Пусть $\\triangle p_i p_j p_k$ соседствует с $\\triangle p_i p_j p_r$ вдоль $\\overline{p_i p_j}$\n\n        1.  $\\overline{p_r p_k} = \\texttt{flip}(\\overline{p_i p_j})$\n\n        2.  $\\texttt{legalize_edge}(p_r, \\overline{p_i p_k}, T)$\n\n        3.  $\\texttt{legalize_edge}(p_r, \\overline{p_k p_j}, T)$\n\n> Гарантируется что данная процедура выполнится за конечное число шагов.\n\n## Вставка вершин\n\n$\\texttt{insert}(p_r, T):$\n\n-   Пусть $t =\\triangle {p_i p_j p_k}$ --- треугольник, покрывающий $p_r$, а $t' = \\triangle p_i p_j p_l$ --- его сосед по ребру $\\overline{p_i p_j}$\n\n    ::: columns\n    ::: {.column width=\"70%\"}\n    -   Если $p_r \\in t^\\circ$:\n\n        1.  Создать ребра $\\overline{p_r p_i}$, $\\overline{p_r p_j}$ и $\\overline{p_r p_k}$\n\n        2.  Выполнить $\\texttt{legalize_edge}(p_r, e, T)$ для каждого $e \\subset t$\n\n    -   Если $p_r \\in \\partial t$, а именно $p_r \\in \\overline{p_i p_j}$:\n\n        1.  Создать ребра $\\overline{p_r p_i}$, $\\overline{p_r p_j}$, $\\overline{p_r p_k}$ и $\\overline{p_r p_l}$\n\n        2.  Выполнить $\\texttt{legalize_edge}(p_r, e, T)$ для каждого $e \\subset t$ и $e' \\subset t'$, кроме $\\overline{p_i p_j}$.\n    :::\n\n    ::: {.column width=\"30%\"}\n    ![](images/insert_point.svg){width=\"100%\"}\n    :::\n    :::\n\n## Триангуляция Делоне --- алгоритм\n\n**Дано**: множество $P$, состоящее из $n$ точек на плоскости\n\n**Получить**: $DT(P)$\n\n1.  Выбрать на плоскости точки $p_{-1}$, $p_{-2}$ и $p_{-3}$, такие что $P \\subset \\triangle p_{-1} p_{-2} p_{-3}$.\n\n2.  Пусть $T = \\Big\\langle \\big\\{p_{-1}, p_{-2}, p_{-3}\\big\\}, \\big\\{\\overline{p_{-1}p_{-2}},~\\overline{p_{-2} p_{-3}}, \\overline{p_{-3}p_{-1}}\\big\\},~\\big\\{\\triangle p_{-1} p_{-2} p_{-3}\\big\\} \\Big\\rangle$.\n\n3.  Перемешать $p_0, p_2,…, p_{n-1}$ в $P$.\n\n4.  Для каждого $r$ от $0$ до $n-1$:\n\n    -   $\\texttt{insert}(p_r, T)$\n\n5.  Удалить $p_{-1}$, $p_{-2}$ и $p_{-3}$, а также связанные с ними ребра и треугольники из $T$\n\n6.  Вернуть $T$.\n\n> Данный алгоритм носит имя Бойера-Ватсона\n\n## Триангуляция Делоне --- алгоритм\n\nУдалить $p_{-1}$, $p_{-2}$ и $p_{-3}$, а также связанные с ними ребра и треугольники из $T$\n\n![](images/tin_building.svg){width=\"100%\"}\n\n## Область и диаграмма Вороного --- алгоритм\n\n**Дано**: $p_i \\in DT(P),~\\texttt{box}(P)$ --- ограничивающий прямоугольник.\n\n**Получить**: $V(p_i)$.\n\n1.  $C(p_i) = \\{\\}$.\n\n2.  Для каждого треугольника $t_j$ последовательности $t_0, ... t_{k-1}$, треугольников, включающих $p_i$ и упорядоченных по часовой стрелке:\n\n    -   добавить в $C(p_i)$ центр описанной окружности $t_j$.\n\n3.  Если последовательность $t_j$ незамкнута ($t_0$ и $t_{k-1}$ не инцидентны), то\n\n    -   добавить в $C(p_i)$ точки, расположенные на пересечении $\\texttt{box}(P)$ и срединных перпендикуляров к ребрам $t_0$ и $t_{k-1}$, принадлежащим выпуклой оболочке $P$\n\n4.  Восстановить $V(p_i)$ по точкам $C(p_i)$.\n\n> Повторяя данный алгоритм для всех $p_i \\in P$ получим диаграмму Вороного.\n\n## Область и диаграмма Вороного --- алгоритм\n\n![](images/voronoy_polygon.svg){width=\"100%\"}\n\n## Альфа-оболочка (вогнутая)\n\n**Альфа-комплекс (** $\\alpha$-complex) подмножество триангуляции Делоне, включающее узлы, а также ребра и треугольники, существующие при заданном радиусе диска $r= 1/\\alpha$ (при $\\alpha > 0$).\n\n![](images/acomplex.png){width=\"100%\"}\n\n-   При увеличении радиуса диска происходит образование и исчезновение циклов.\n\n-   Объединение треугольников называется **альфа-оболочкой**.\n\n-   При $\\alpha = 0$ альфа-оболочка совпадает с *выпуклой оболочкой* множества точек.\n\n## Триангуляция полигона\n\n::: columns\n::: {.column width=\"50%\"}\n\nТриангуляция полигона\n\n:   Разбиение полигона на треугольники максимальным числом непересекающихся диагоналей\n\nДиагональ полигона\n\n:   Открытый отрезок, соединяющий вершины полигона и лежащий в его внутренней области\n\n::: callout-tip\n## Применение\n\nТриангуляция полигона играет вспомогательную роль во многих задачах. В частности, она необходима для поиска центроида и срединной оси полигона, а также его визуализации средствами графического процессора.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/polygon_tri5.svg){width=\"100%\"}\n:::\n:::\n\n## Монотонный полигон\n\n::: columns\n::: {.column width=\"50%\"}\n\nМонотонный полигон\n\n:   Полигон $A$ называется монотонным по отношению к прямой $l$, если любая прямая $l'$, перпендикулярная $l$, пересекает его не более 2 раз.\n\n-   При триангуляции полигон разбивается на множество *монотонных* полигонов.\n\n-   Часто используется монотонность по отношению к одной из осей координат. Например, *Y*-монотонные.\n\n    -   При движении от вершины с $\\max(Y)$ к вершине с $\\min(Y)$ граница всегда следует вниз.\n:::\n\n::: {.column width=\"50%\"}\n![](images/polygon_tri6.svg){width=\"100%\"}\n:::\n:::\n\n## Особые точки полигона\n\nОсобые точки нужны для разбиения полигона на монотонные части\n\n![](images/point_types.svg){width=\"100%\"}\n\n## Особые точки полигона\n\nПонятия \"выше\" и ниже необходимо формализовать, т.к. точки могут иметь одинаковые координаты Y.\n\n-   Точка $p$ **ниже** точки $q$, если:\n\n    $$\n    \\big(y_p < y_q\\big) \\lor \\big( (y_p = y_q) \\land (x_p > x_q) \\big)\n    $$\n\n-   Точка $p$ **выше** точки $q$, если:\n\n    $$\n    \\big(y_p > y_q\\big) \\lor \\big( (y_p = y_q) \\land (x_p < x_q) \\big)\n    $$\n\n::: callout-tip\n## Монотонность и статус точки\n\nПолигон является Y-монотонным, если он не содержит точек слияния и разбиения.\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа первом проходе алгоритма обрабатываются **точки разбиения**.\n\n1.  Для каждой точки $v$ найти расположенное слева ребро $\\texttt{left}(v)$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_split1.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа первом проходе алгоритма обрабатываются **точки разбиения**.\n\n1.  Для каждой точки $v$ найти расположенное слева ребро $\\texttt{left}(v)$\n2.  Если $v$ точка разбиения, то построить диагональ $\\overline{vw}$ для самой нижней точки $w$ над $v$ такой, что $\\texttt{left}(w) = \\texttt{left}(v)$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_split2.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа первом проходе алгоритма обрабатываются **точки разбиения**.\n\n1.  Для каждой точки $v$ найти расположенное слева ребро $\\texttt{left}(v)$\n2.  Если $v$ точка разбиения, то построить диагональ $\\overline{vw}$ для самой нижней точки $w$ над $v$ такой, что $\\texttt{left}(w) = \\texttt{left}(v)$.\n3.  Если такой точки не найдено, принять за $w$ верхний конец $\\texttt{left}(v)$ и построить диагональ $\\overline{vw}$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_split3.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа втором проходе алгоритма обрабатываются **точки слияния**.\n\n1.  Для каждой точки $v$ найти расположенное справа ребро $\\texttt{right}(v)$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_merge1.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа первом проходе алгоритма обрабатываются **точки слияния**.\n\n1.  Для каждой точки $v$ найти расположенное справа ребро $\\texttt{right}(v)$\n2.  Если $v$ точка слияния, то построить диагональ $\\overline{vw}$ для самой верхней точки $w$ под $v$ такой, что $\\texttt{right}(w) = \\texttt{right}(v)$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_merge2.svg){width=\"100%\"}\n:::\n:::\n\n## Разбиение на *Y*-монотонные полигоны\n\n::: columns\n::: {.column width=\"50%\"}\nНа первом проходе алгоритма обрабатываются **точки слияния**.\n\n1.  Для каждой точки $v$ найти расположенное справа ребро $\\texttt{right}(v)$\n2.  Если $v$ точка слияния, то построить диагональ $\\overline{vw}$ для самой верхней точки $w$ под $v$ такой, что $\\texttt{right}(w) = \\texttt{right}(v)$.\n3.  Если такой точки не найдено, принять за $w$ нижний конец $\\texttt{right}(v)$ и построить диагональ $\\overline{vw}$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/monotone_poly_merge3.svg){width=\"100%\"}\n:::\n:::\n\n## Стек\n\n**Стек** --- одномерная структура данных, действующая по принципу *LIFO (Last In First Out)*.\n\nCтек поддерживает следующие операции:\n\n-   `push()` --- добавление элемента в конец\n\n-   `pop()` --- извлечение элемента с конца\n\n-   `top()` --- просмотр последнего элемента\n\n```         \nS = stack()\nS.push(2) # [2]\nS.push(5) # [2, 5]\nS.push(0) # [2, 5, 0]\na = S.pop() # 0\nb = S.pop() # 5\nS.push(7) # [2, 7]\nS.top() # 7\n```\n\n## Триангуляция *Y*-монотонного полигона\n\n1.  Отсортировать все вершины $v_i$ по убыванию $Y$\n\n2.  Список ребер $E \\leftarrow \\varnothing$; cтек вершин $S \\leftarrow \\varnothing$; $S.\\texttt{push}(v_0)$; $S.\\texttt{push}(v_1)$\n\n3.  В цикле по $i$ от $2$ до $n-2$:\n\n    ::: columns\n    ::: {.column width=\"50%\"}\n    -   *если* $v_i$ и $S.\\texttt{top}()$ на противоположных сторонах:\n        -   пока $|S|>0$:\n            -   $u \\leftarrow S.\\texttt{pop}()$\n            -   $E = E \\cup \\overline{v_i u}$ если $|S| > 0$\n        -   $S.\\texttt{push}(v_{i-1})$; $S.\\texttt{push}(v_{i})$\n    :::\n\n    ::: {.column width=\"50%\"}\n    -   *иначе*:\n        -   $u \\leftarrow S.\\texttt{pop}()$\n        -   пока $|S|>0$ и $v_i$ *видит* $S.\\texttt{top}()$:\n            -   $u \\leftarrow S.\\texttt{pop}()$\n            -   $E = E \\cup \\overline{v_i u}$\n        -   $S.\\texttt{push}(u)$; $S.\\texttt{push}(v_{i})$\n    :::\n    :::\n\n4.  Соединить $v_{n-1}$ со всеми вершинами в $S$ кроме первой и последней.\n\n## Триангуляция монотонных полигонов\n\nРезультат объединяется из триангуляций Y-монотонных полигонов.\n\n![](images/polygon_tri4.svg){width=\"100%\"}\n\n## Срединная ось полигона\n\n::: columns\n::: {.column width=\"50%\"}\nСрединная ось полигона может быть аппроксимирована через *двойственный граф* его триангуляции.\n\nДвойственный граф\n\n:   Двойственный граф $G'$ к планарному графу $G$ --- это граф, в котором вершины соответствуют граням $G$, а ребра соединяют соседние грани $G$.\n\nВ качестве вершин двойственного графа можно выбрать центроиды треугольников. Для треугольника $\\triangle p q r$:\n\n$$\nc_{\\triangle} = \\frac{1}{3} (p + q + r)\n$$\n:::\n\n::: {.column width=\"50%\"}\n![](images/skeleton.svg){width=\"100%\"}\n:::\n:::\n\n## Центроид полигона\n\n::: columns\n::: {.column width=\"40%\"}\nНаиболее простой вариант --- осреднить координаты вершин полигона:\n\n$$\nc = \\frac{1}{n}\\sum_{i=0}^{n-1} v_i\n$$\n\n::: callout-warning\n## Недостаток\n\nЦентроид будет смещен в ту сторону, где граница полигона имеет более высокую детализацию.\n:::\n:::\n\n::: {.column width=\"60%\"}\n![](images/polygon_centroid1.svg){width=\"100%\"}\n:::\n:::\n\n## Центроид полигона\n\n::: columns\n::: {.column width=\"40%\"}\nБолее устойчивый способ --- осреднить центроиды $k$ граней триангуляции полигона $t$ с весами, пропорциональными их площади:\n\n$$\nc = \\frac{1}{\\texttt{area}(A)}\\sum_{j=0}^{k-1} \\texttt{area}(t_j)c_j\n$$\n\n::: callout-warning\n## Недостаток\n\nЦентроид может выходить за пределы полигона.\n:::\n:::\n\n::: {.column width=\"60%\"}\n![](images/polygon_centroid2.svg){width=\"100%\"}\n:::\n:::\n\n## Точка на поверхности\n\n::: columns\n::: {.column width=\"60%\"}\n**Точка на поверхности** (`POINT_ON_SURFACE`) --- разновидность центроида, которая гарантированно внутри полигона.\n\n1.  Вычислить ограничивающий прямоугольник полигона.\n\n2.  Сгенерировать $N$ горизонтальных или вертикальных линий, пересекающих полигон.\n\n3.  Вычислить пересечения между линиями и полигоном.\n\n4.  Выбрать в качестве центроида середину самого длинного пересечения.\n:::\n\n::: {.column width=\"40%\"}\n![](images/point_on_surface.svg){width=\"100%\"}\n:::\n:::\n\n## Библиография\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}