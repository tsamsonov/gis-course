{
  "hash": "374968f84cbd000f5a45b0ef0663904e",
  "result": {
    "markdown": "---\ntitle: \"Модель OGC Simple Features\"\nsubtitle: \"Геоинформатика I. Базы пространственных данных\"\ndate: today\ndate-format: long\nauthor: \"Самсонов Тимофей Евгеньевич\"\nexecute:\n  echo: false\n  freeze: true\nengine: knitr\nformat:\n  revealjs: \n    theme: [default, custom.scss]\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: \"Самсонов Т. Е. Геоинформатика: курс лекций\"\n    header-includes: <link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n\n## Simple Features\n\n**Simple Features** --- стандарт @OGC2010, который определяет общую модель хранения и доступа к простым (векторным) объектам.\n\n-   все геометрии состоят из точек;\n-   все точки в геометрии имеют одинаковую размерность;\n-   размерность точек может быть 2, 3 или 4.\n\nВ дополнение к обязательным измерениям $X$ и $Y$ *возможны*:\n\n-   $Z$, обозначающее высоту\n-   $M$, обозначающее некоторую меру --- например, время\n\nСуществует 4 варианта координат: $XY$, $XYZ$, $XYM$ и $XYZM$.\n\nВ географических координатах $X$ --- долгота, $Y$ --- широта.\n\n## Иерархия классов\n\n![](images/sf_hierarchy.svg){width=\"100%\"}\n\nМодель *Simple Features* представляет собой иерархию классов, между которыми существуют отношения **наследования** (**△**) и **коллекции** (**♢**).\n\n## Geometry\n\nВсе объекты типа *Simple Features* наследуют свойства от базового класса **`GEOMETRY`**. Механизм этого наследования основан на следующих принципах:\n\n1.  **`GEOMETRY`** представляет собой *абстрактный* класс, т.е. вы не можете создать экземпляр этого класса.\n\n2.  Все подклассы геометрий являются замыканиями, т.е. включают границу в множество точек.\n\n3.  На уровне класса **`GEOMETRY`** определен интерфейс --- набор методов, которые позволяют получить информацию об объекте.\n\n4.  Реализация интерфейса зависит от конкретного класса.\n\n5.  С каждым классом геометрии ассоциированы системы отсчета, которые определяют пространственные ($XYZ$) и дополнительные ($M$) измерения.\n\n## Интерфейс класса `GEOMETRY`\n\n| Метод            | Описание                                                                                                                                                                             |\n|-------------|-----------------------------------------------------------|\n| `Dimension()`    | Пространственная размерность *данного* геометрического объекта. Меньше или равна размерности координат. Для гетерогенных коллекций --- максимальная размерность содержимых объектов. |\n| `GeometryType()` | Имя подтипа класса `GEOMETRY`, экземпляром которого является *данный* объект.                                                                                                        |\n| `SRID()`         | Идентификатор пространственной системы отсчета (SRS) данного объекта. Как правило, является внешним ключом к таблице систем отсчета.                                                 |\n\n## Интерфейс класса `GEOMETRY`\n\n| Метод        | Описание                                                                                                                                                                                                                                                                                                      |\n|------------|------------------------------------------------------------|\n| `Envelope()` | Минимальный ограничивающий прямоугольник данного объекта, параллельный осям координат. Полигон, определяемый углами $(X_{min}, Y_{min})$, $(X_{min}, Y_{max})$, $(X_{max}, Y_{max})$, $(X_{max}, Y_{min})$, $(X_{min}, Y_{min})$. При этом в фактических реализациях достаточно указать минимумы и максимумы. |\n| `AsText()`   | Экспортирует данный геометрический объект в конкретное представление вида *Well-Known Text (WKB)*                                                                                                                                                                                                             |\n| `AsBinary()` | Экспортирует данный геометрический объект в конкретное представление вида *Well-Known Binary (WKB)*                                                                                                                                                                                                           |\n\n## Интерфейс класса `GEOMETRY`\n\n| Метод        | Описание                                                                                                                                                                                            |\n|------------|------------------------------------------------------------|\n| `IsEmpty()`  | Возвращает `TRUE` ($1$), если *данный* геометрический объект пуст, т.е. представляет пустое множество точек $\\varnothing$ в координатном пространстве; возвращает `FALSE` ($0$) в противном случае. |\n| `IsSimple()` | Возвращает `TRUE` ($1$), если *данный* геометрический объект не содержит аномальных точек, таких как самопересечения и самокасания; возвращает `FALSE` ($0$) в противном случае.                    |\n\n## Интерфейс класса `GEOMETRY`\n\n| Метод          | Описание                                                            |\n|-----------------|-------------------------------------------------------|\n| `Is3D()`       | Возвращает `TRUE` ($1$), если *данный* объект имеет координаты $Z$. |\n| `IsMeasured()` | Возвращает `TRUE` ($1$), если *данный* объект имеет координаты $M$. |\n| `Boundary()`   | Возвращает *замыкание* комбинаторной границы *данного* объекта      |\n\n::: callout-important\n## Важно\n\nНазвания методов в программных реализациях Simple Features могут отличаться от предлагаемых в стандарте. Однако наличие соответствующих методов является условием реализации стандарта.\n:::\n\n## Граница и замыкание\n\nГраничная точка\n\n:   Точка, в любой окрестности которой находятся как принадлежащие, так и не принадлежащие множеству точки\n\nГраница множества $\\partial A$\n\n:   Совокупность граничных точек множества\n\nЗамыкание множества $\\overline A$\n\n:   Объединение множества и его границы: $\\overline A = A \\cup \\partial A$\n\nДополнение множества $A^-$, вложенного в $\\mathbb R^n$ ($A \\subset \\mathbb R^n$)\n\n:   Множество всех точек $\\mathbb R^n$, не являющихся элементами множества: $A^- = \\mathbb R^n \\backslash A$\n\nВнутренность множества ($A^{\\circ}$)\n\n:   Объединение всех открытых подмножеств множества: $A^\\circ = \\mathbb R^n \\backslash \\overline{A^-}$\n\n## Топологическая граница\n\n![](images/topological_boundary.svg){width=\"100%\"}\n\n## Симплекс\n\nСимплекс $\\Delta^n$\n\n:   Геометрическая фигура, являющаяся $n$-мерным обобщением треугольника\n\nОстов симплекса\n\n:   Множество его вершин\n\nГрань симплекса размерности $s$\n\n:   $s$-мерный симплекс, остов которого является подмножеством остова $\\Delta^n$.\\\n    *Ребро* --- это грань размерности $1$.\n\n![](images/simplices.svg){width=\"100%\"}\n\n## Комплекс\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/complex.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\n\nСимплициальный комплекс $\\mathcal K$\n\n:   Множество симплексов, удовлетворяющее условиям:\n\n    1.  Все грани каждого симплекса из $\\mathcal K$ также принадлежат $\\mathcal K$\n    2.  Непустое пересечение двух симплексов $\\sigma_1, \\sigma_2 \\in \\mathcal K$ является гранью как $\\sigma_1$, так и $\\sigma_2$.\n\nСимплициальный $n$-комплекс $\\mathcal K$\n\n:   $\\mathcal K$, в котором наибольшее измерение какого-либо симлекса равно $n$\n\nТриангуляция\n\n:   Разбиение геометрического объекта на симплексы\n:::\n:::\n\n## Комбинаторная граница\n\nКомбинаторная граница $\\partial \\mathcal K$ $n$-комплекса $\\mathcal K$\n\n:   Множество $(n-1)$-симплексов $\\mathcal K$, каждый из которых входит в состав только одного $n$-симплекса $\\mathcal K$.\n\n![](images/combinatorial_solo.svg){width=\"60%\"}\n\n## Граница Simple Features\n\nЗамыкание комбинаторной границы *данного* объекта\n\n![](images/combinatorial_boundary.svg){width=\"100%\"}\n\n## Геометрическая коллекция\n\n`GEOMETRYCOLLECTION` --- коллекция геометрических элементов\n\n-   Единственное ограничение: все элементы коллекции должны иметь единую пространственную систему отсчета.\n\n-   Подклассы могут накладывать дополнительные ограничения.\n\n-   Порядок элементов коллекции не имеет значения.\n\n-   Интерфейс должен поддерживать методы `NumGeometries()` и `GeometryN()`\n\n| Метод             | Назначение                                                          |\n|------------------|------------------------------------------------------|\n| `NumGeometries()` | Возвращает количество геометрий в *данной* геометрической коллекции |\n| `GeometryN(n)`    | Возвращает $n$-ную геометрию в данной геометрической коллекции      |\n\n## Точка (`POINT`)\n\n::: columns\n::: {.column width=\"50%\"}\n`POINT` --- $0$-мерный геометрический объект, единичное местоположение\n\nГраница `POINT` --- пустое множество: $\\partial A = \\varnothing$\n\nИнтерфейс точки должен поддерживать возвращение ее координат:\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](adv_02_Features_files/figure-revealjs/unnamed-chunk-1-1.png){width=300px height=300px}\n:::\n:::\n\n:::\n:::\n\n| Метод | Назначение                                                           |\n|-------------|-----------------------------------------------------------|\n| `X()` | Координата $x$ *данного* объекта `POINT`                             |\n| `Y()` | Координата $y$ *данного* объекта `POINT`                             |\n| `Z()` | Координата $z$ *данного* объекта `POINT`, или `NULL` если не задано. |\n| `M()` | Координата $m$ *данного* объекта `POINT`, или `NULL` если не задано. |\n\n## Мультиточка (`MULTIPOINT`)\n\n`MULTIPOINT` --- $0$-мерная геометрическая коллекция объектов класса `POINT`.\n\n::: columns\n::: {.column width=\"70%\"}\n-   Элементы коллекции не связаны и не имеют какого-либо смыслового упорядочения (наследуется свойство `GEOMETRYCOLLECTION` ).\n\n-   Граница `MULTIPOINT` --- пустое множество: $\\partial A = \\varnothing$.\n\n-   Объект `MULTIPOINT` является простым, если ни одна пара `POINT` в его коллекции не совпадает.\n:::\n\n::: {.column width=\"30%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](adv_02_Features_files/figure-revealjs/unnamed-chunk-2-3.png){width=400px height=200px}\n:::\n:::\n\n:::\n:::\n\n\n```{mermaid}\n%%| fig-width: 9\nflowchart LR\n  A(MULTIPOINT) -->|\"GeometryN( 0 )\"| B(POINT)\n  B -->|\"X( )\"| C(X)\n  B -->|\"Y( )\"| D(Y)\n```\n\n\n## Кривая (`CURVE`)\n\n`CURVE` --- одномерный геометрический объект, хранимый в виде последовательности точек.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/curve.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\nКривая определяется как непрерывное отображение отрезка в пространство:\n\n$$f: [a, b] \\rightarrow R^n$$\n\n-   Это абстрактный класс, вы не можете создать объект `CURVE`.\n\n-   Интерполяция между точками определяется конкретным подклассом `CURVE`.\n\n-   Стандарт определяет только подкласс `LINESTRING`, в котором используется линейная интерполяция.\n:::\n:::\n\n## Кривая (`CURVE`)\n\n-   Кривая является *простой*, если она не проходит дважды через одну и ту же точку, за исключением начальной и конечной точки:\n\n$$\n\\texttt{f.IsSimple()} \\Leftrightarrow \\boxed{f(t_1)=f(t_2) \\land t_1 \\neq t_2 \\color{red}{\\Rightarrow} t_1 = a \\land t_2 = b}  \n$$\n\n-   Кривая является замкнутой, если ее начальная точка равна конечной точке:\n\n    $$\n    \\texttt{f.IsClosed()} \\Leftrightarrow \\boxed{f(a)=f(b)}  \n    $$\n\n-   Граница замкнутой кривой является пустым множеством:\n\n    $$\n    \\texttt{f.IsClosed()} \\Leftrightarrow \\boxed{\\partial f=\\varnothing}  \n    $$\n\n## Кривая (`CURVE`)\n\n-   Граница незамкнутой кривой содержит ее конечные точки:\n\n    $$\n    \\texttt{!f.IsClosed()} \\Leftrightarrow \\boxed{\\partial f=\\{f(a), f(b)\\}} \n    $$\n\n-   Простая и замкнутая кривая является *кольцом* (`RING`).\n\n-   Интерфейс объекта `CURVE` включает следующие методы:\n\n| Метод          | Назначение                                               |\n|------------------|------------------------------------------------------|\n| `Length()`     | Длина данного объекта `CURVE` в ассоциированной СК       |\n| `StartPoint()` | Начальная точка данного объекта `CURVE`                  |\n| `EndPoint()`   | Конечная точка данного объекта `CURVE`                   |\n| `IsClosed()`   | `TRUE`, если `StartPoint() == EndPoint()`                |\n| `IsRing()`     | `TRUE`, если `IsSimple()` и `StartPoint() == EndPoint()` |\n\n## Линия (`LINESTRING`, `LINE`, `LINEARRING`)\n\n`LINESTRING` --- это `CURVE` с линейной интерполяцией между точками.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/linestrings.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\n-   Каждая пара последовательных точек определяет отрезок\n\n-   `LINE` --- это `LINESTRING` из двух точек\n\n-   `LINEARRING` --- это простой замкнутый `LINESTRING`\n\n-   Интерфейс содержит дополнительные методы:\n\n| Метод         | Назначение                                     |\n|---------------|------------------------------------------------|\n| `NumPoints()` | Количество точек в данном объекте `LINESTRING` |\n| `PointN(n)`   | $n$-я точка данного объекта `LINESTRING`       |\n:::\n:::\n\n## Мультикривая (`MULTICURVE`)\n\n`MULTICURVE` представляет 1-мерный подкласс `GEOMETRYCOLLECTION` --- коллекцию объектов `CURVE`.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/multicurve_borders.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\n-   `MULTICURVE` как и `CURVE` является абстрактным классом. Вы не можете создать объект данного класса.\n\n-   `MULTICURVE` является *простым*, если каждый его элемент является простым, а их пересечения происходят только в граничных точках.\n\n-   Точка принадлежит границе объекта `MULTICURVE` если она принадлежит границам *нечетного* числа его элементов.\n\n-   Объект `MULTICURVE` замкнут, если замкнуты всего его элементы.\n\n-   Граница замкнутого объекта `MULTICURVE` всегда пуста.\n:::\n:::\n\n## Мультикривая (`MULTICURVE`)\n\n`MULTICURVE` представляет 1-мерный подкласс `GEOMETRYCOLLECTION` --- коллекцию объектов `CURVE`.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/closed_multicurves.svg){width=\"80%\"}\n:::\n\n::: {.column width=\"70%\"}\nИнтерфейс `MULTICURVE` дополнительно к `GEOMETRYCOLLECTION` реализует следующие методы:\n\n| Метод        | Назначение                                                                                                                                                                |\n|-------------|-----------------------------------------------------------|\n| `IsClosed()` | `TRUE` ($1$) если *данный* объект `MULTICURVE` является замкнутым (т.е. каждый объект `CURVE` в коллекции является замкнутым. Возвращает `FALSE` ($0$) в противном случае |\n| `Length()`   | Длина данного объекта `MULTICURVE`, которая равна сумме длин элементов коллекции.                                                                                         |\n:::\n:::\n\n## Мультилиния (`MULTILINESTRING`)\n\n`MULTILINESTRING` --- это `MULTICURVE` с элементами класса `LINESTRING`.\n\n![](images/multilinestrings.svg){width=\"100%\"}\n\n## Поверхность (`SURFACE`)\n\n`SURFACE` --- это $2$-мерный геометрический объект.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/surface.svg){width=\"80%\"}\n:::\n\n::: {.column width=\"70%\"}\n-   **Простая** поверхность состоит из единичной области (*\"patch\"*), которая соответствует одной внешней границе, а также $0$ и более внутренних границ.\n\n-   Простая поверхность в 3-мерном пространстве изоморфна планарной поверхности с точностью до поворота на плоскость $z = 0$.\n\n-   **Полиэдральная** поверхность формируется \"склеиванием\" простых поверхностей по общим границам (*полиэдр* --- объединение многогранников).\n\n-   Если нормали всех компонент полиэдральной поверхности параллельны, то она может быть представлена в виде простой поверхности.\n:::\n:::\n\n## Поверхность (`SURFACE`)\n\n-   `SURFACE` --- это абстрактный класс, вы не можете создать объект этого класса.\n\n-   Граница объекта `SURFACE` --- это множество объектов класса `CURVE`, соответствующих его *внешней* и (опционально) *внутренним* границам.\n\n-   Интерфейс класса имеет дополнительные методы:\n\n| Метод              | Назначение                                                                                                          |\n|---------------|---------------------------------------------------------|\n| `Area()`           | Площадь данного объекта `SURFACE` в его системе координат                                                           |\n| `Centroid()`       | Математический центроид данного объекта `SURFACE` как объект класса `POINT`. Может находиться за пределами объекта. |\n| `PointOnSurface()` | Объект класса `POINT`, который гарантированно принадлежит данному объекту `SURFACE`.                                |\n\n## Полигон (`POLYGON`) и треугольник (`TRIANGLE`)\n\n`POLYGON` --- плоская поверхность с одной внешней и 0+ внутренних границ\n\n-   Границы `POLYGON` имеют класс `LINEARRING`.\n\n-   *Внешняя* граница против часовой стрелки, *внутренние* --- по часовой.\n\n-   `TRIANGLE` --- это `POLYGON` из 3 различных, неколлинеарных точек.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/contour_direction.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\n| Метод               | Назначение                                                        |\n|------------------|------------------------------------------------------|\n| `ExtriorRing()`     | Внешнее кольцо *данного* `POLYGON` в виде `LINESTRING`            |\n| `NumInteriorRing()` | Количество внутренних колец *данного* `POLYGON`                   |\n| `InteriorRingN(n)`  | $n$-ное внутреннее кольцо *данного* `POLYGON` в виде `LINESTRING` |\n:::\n:::\n\n## Полигон (`POLYGON`)\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/illegal_polygons.svg){width=\"80%\"}\n:::\n\n::: {.column width=\"70%\"}\n**Дополнительные проверки:**\n\n-   *Внутренняя* область полигона $P^\\circ$ --- линейно связное множество.\n\n-   *Внешняя* область полигона $P^-$ с 1 и более дырок --- линейно несвязное множество.\n\n-   Границы полигона не могут перекрываться, а их пересечение возможно только в форме касания в точке.\n\n-   Полигон не может иметь линий разреза, шипов и проколов. Формально это означает, что *полигон совпадает с замыканием его внутренней области*: $P = \\overline{P^\\circ}$.\n:::\n:::\n\n## `POLYHEDRALSURFACE` и `TIN`\n\n`POLYHEDRALSURFACE` --- коллекция полигонов, которые имеют общие границы.\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/polyhedral.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"70%\"}\n-   Для каждой пары касающихся полигонов их общая граница должна быть представима в виде коллекции объектов `LINESTRING`.\n\n-   Каждый такой `LINESTRING` должен входить в состав не более чем $2$-х полигонов.\n\n-   Направление обхода контура у всех граней `POLYHEDRALSURFACE` должно быть одинаковым. Два соседних полигона проходят общую границу в противоположных направлениях.\n\n-   `TIN` *(Triangular Irregular Network)* --- это `POLYHEDRALSURFACE`, который состоит из объектов класса `TRIANGLE`.\n:::\n:::\n\n## `POLYHEDRALSURFACE` и `TIN`\n\nИнтерфейс `POLYHEDRALSURFACE` дополнительно поддерживает следующие методы:\n\n| Метод                 | Назначение                                                                                                      |\n|----------------|--------------------------------------------------------|\n| `NumPatches()`        | Количество полигонов *данного* объекта `POLYHEDRALSURFACE`                                                      |\n| `PatchN(n)`           | $n$-ный полигон *данного* объекта `POLYHEDRALSURFACE` в виде объекта `POLYGON`                                  |\n| `BoundingPolygons(p)` | Коллекция полигонов, которые граничат с `p` в данном объекте `POLYHEDRALSURFACE` в виде объекта `MULTIPOLYGON`. |\n| `IsClosed()`          | `TRUE`, если поверхность замкнута сама на себя, т.е. не имеет границы и оконтуривает сплошное тело.             |\n\n## Мультиповерхность (`MULTISURFACE`)\n\n::: columns\n::: {.column width=\"30%\"}\n![](images/multisurface.svg){width=\"80%\"}\n:::\n\n::: {.column width=\"70%\"}\n`MULTISURFACE` --- 2-мерный объект класса `GEOMETRYCOLLECTION`, элементами которого являются объекты класса `SURFACE`.\n\n-   Внутренние области любых двух поверхностей в коллекции не могут пересекаться.\n\n-   Границы любых двух поверхностей в коллекции могут пересекаться только в конечном числе точек.\n\n-   В случае касания вдоль кривой поверхности могут быть объединены.\n\n-   Дополнительные методы аналогичны методам `SURFACE`.\n:::\n:::\n\n## Мультиполигон (`MULTIPOLYGON`)\n\n`MULTIPOLYGON` --- это объект класса `MULTISURFACE`, элементы которого являются объектами класса `POLYGON`.\n\n::: columns\n::: {.column width=\"25%\"}\n![](images/multipolygons.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"75%\"}\n-   `MULTIPOLYGON` наследует все ограничения, действующие для объектов классов `MULTISURFACE` и `POLYGON`.\n\n-   Внутренняя область объекта `MULTIPOLYGON` , включающего 2 и более полигонов, не является линейно связной. Количество компонент = количество полигонов.\n\n-   Границей объекта `MULTIPOLYGON` является множество замкнутых объектов `LINESTRING`, соответствующих границам вложенных объектов `POLYGON`.\n\n-   `POLYHEDRALSURFACE` не является мультиполигоном, т.к. может нарушать правило касания в конечном числе точек.\n:::\n:::\n\n## Иерархия классов\n\n![](images/sf_hierarchy.svg){width=\"100%\"}\n\nМодель *Simple Features* представляет собой иерархию классов, между которыми существуют отношения **наследования** (**△**) и **коллекции** (**♢**).\n\n## Библиография\n",
    "supporting": [
      "adv_02_Features_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}